[{"id":0,"href":"/docs/docs/learning_old/reference/api/src/","title":"Sources","section":"API","content":" Source # noise # noise( scale = 10, offset = 0.1 )\nGenerate Perlin noise.\nvoronoi # voronoi( scale = 5, speed = 0.3, blending = 0.3 )\nGenerate voronoi shapes.\nosc # osc( frequency = 60, sync = 0.1, offset )\nshape # shape( sides = 3, radius = 0.3, smoothing = 0.01 )\ngradient # gradient( speed )\nsrc # src( tex )\nSee hydra-examples repository\nsolid # solid( r, g, b, a = 1 )\nprev # prev( )\nout # out( texture = all )\n"},{"id":1,"href":"/docs/docs/learning_tutorial/next-steps/arrays/","title":"Change values over time using arrays and custom functions","section":"Next Steps","content":" Sequencing using Arrays # If you\u0026rsquo;re coding in Hydra, you\u0026rsquo;re constantly trying many values to input to the sources and transforms, and it\u0026rsquo;s just a matter of time until you like how more than one looks, and you want to somehow switch between them. We\u0026rsquo;ll be referring to this idea of arguments whose value change over time as dynamic arguments. And there are two main ways to achieve this in Hydra: Arrays and functions.\nSequence your inputs # When you send an Array as an input (indicated in javascript by []), Hydra will automatically switch and jump from each element from the Array to the next one. When there are no more elements, it wraps all the way back to the beginning. Let\u0026rsquo;s see it in action:\nchanging the speed # The arrays in hydra have a default bpm(beats-per-minute) of 30. You can change the speed of a specific array by adding .fast() at the end of the array. For example .fast(4) will make the above array run four times faster.\nThe speed of all arrays in a sketch can be changed using the bpm parameter of hydra synth.\nbpm = 60 smooth() interpolation # You can also interpolate between values instead of jumping from one to the other. That is, smoothly transition between values. For this you can use the .smooth method. It may take a Number argument (defaulted to 1) which controls the smoothness.\nSee reference: arrays for a more detailed explanation and example usage of arrays and sequencing in Hydra.\nCustom Functions # An even more flexible way of creating dynamic inputs to a hydra sketch is using custom funcitons. This can be useful for creating parameters that change over time, as well as creating sketches that respond to external inputs, such as the mouse, audio input, or MIDI controllers.\nEach numerical parameter in hydra can be defined as a function rather than a static variable. When Hydra takes a function as an argument,it will evaluate it every time that function every time it renders a frame. The return of the function will be used as the value for that parameter during that frame render. For example,\nosc(function(){return 100 * Math.sin(time * 0.1)}).out() modifies the oscillator frequency as a function of time. (Time is a global variable that represents the milliseconds that have passed since loading the page).\nThe above example can be written more concisely using es6 syntax:\nosc(() =\u0026gt; 100 * Math.sin(time * 0.1)).out() The time variable seen there is a variable pre-declared by Hydra, that stores how much time passed since Hydra started in seconds.\nFunctions used in Hydra don\u0026rsquo;t need to be arrow functions, any no-argument function will do! Make sure your function is returning a Number to avoid errors.\nThe time variable # When you use functions that can take numerical arguments, time will allow you to have their values evolve through\u0026hellip; time. If you multiply time by some value it\u0026rsquo;s as if time goes faster, while dividing while act as making time go slower. For example Math.sin(time*4) will go 4 times faster than Math.sin(time).\nThose users more familiar with mathematics might see this as:\ny(t) = t : ()=\u0026gt;time y(t) = A sin(f t + ph) : ()=\u0026gt;amplitude*Math.sin(freq*time + phase) We recommend getting familiar with some of the methods in the JS built-in Math object. Learn more about it here\n"},{"id":2,"href":"/docs/docs/learning_tutorial/getting-started/","title":"Getting Started","section":"learning","content":" Getting started with hydra # This document is an introduction to making live visuals using Hydra. It covers the basics of writing code in the browser to generate and mix live video sources. No coding or video experience is necessary!\nIf you just want to start in 60 seconds you can also check:\nGetting started short version This tutorial is meant to be used from within the hydra web editor. It is also interactive \u0026ndash; you can directly modify the code in each code block to see how it affects the visuals.\nGet to know the browser editor # To get started, open the the hydra web editor in a separate window. Close the top window by clicking the [x] in the top right.\nYou will see some colorful visuals in the background with text on top in the top left of the screen. The text is code that generates the visuals behind it.\nAt the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter) upload to gallery upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL clear all resets the environment and clears text from the editor show random sketch. Loads random sketch examples. Always it is a good way to learn Hydra by studying someone elses code. make random change dices modify values automatically. Try it with some of the sketch examples. show info window show overlay window with help text and links "},{"id":3,"href":"/docs/docs/quick-start/","title":"quick start","section":"Docs","content":" Hello World ! # Start writing code in hydra! to get started:\nGo to https://hydra.ojack.xyz.\nClose the top window by clicking the [x] in the top right.\nChange some numbers.\nType ctrl+shift+enter to run the code (or use the triangle run button on the top right corner).\nHave fun! There is no \u0026ldquo;wrong\u0026rdquo; way to code in hydra :]\nNext steps # For a more in-depth introduction, see the \u0026ldquo;Getting Started\u0026rdquo; page. For an overview of available guides and resources, see the \u0026ldquo;learning\u0026rdquo; area.\n"},{"id":4,"href":"/docs/docs/learning_old/reference/api/coord/","title":"Geometry","section":"API","content":" Geometry # rotate # rotate( angle = 10, speed )\nRotate texture.\nscale # scale( amount = 1.5, xMult = 1, yMult = 1, offsetX = 0.5, offsetY = 0.5 )\nScale texture.\npixelate # pixelate( pixelX = 20, pixelY = 20 )\nPixelate texture with pixelX segments and pixelY segments.\nrepeat # repeat( repeatX = 3, repeatY = 3, offsetX, offsetY )\nrepeatX # repeatX( reps = 3, offset )\nrepeatY # repeatY( reps = 3, offset )\nkaleid # kaleid( nSides = 4 )\nKaleidoscope effect with nSides repetition.\nscroll # scroll( scrollX = 0.5, scrollY = 0.5, speedX, speedY )\nscrollX # scrollX( scrollX = 0.5, speed )\nscrollY # scrollY( scrollY = 0.5, speed )\n"},{"id":5,"href":"/docs/docs/learning_old/getting-started/","title":"Getting started with hydra","section":"learning","content":" Getting started with hydra # This document is an introduction to making live visuals using Hydra. It covers the basics of writing code in the browser to generate and mix live video sources. No coding or video experience is necessary!\nIf you just want to start in 60 seconds you can also check:\nGetting started short version This tutorial is meant to be used from within the hydra web editor. It is also interactive \u0026ndash; you can directly modify the code in each code block to see how it affects the visuals.\nGet to know the browser editor # To get started, open the the hydra web editor in a separate window. Close the top window by clicking the [x] in the top right.\nYou will see some colorful visuals in the background with text on top in the top left of the screen. The text is code that generates the visuals behind it.\nAt the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter) upload to gallery upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL clear all resets the environment and clears text from the editor show random sketch. Loads random sketch examples. Always it is a good way to learn Hydra by studying someone elses code. make random change dices modify values automatically. Try it with some of the sketch examples. show info window show overlay window with help text and links First line of code # Use the clear all button to erase the previous sketch.\nThen, type or paste the following in the editor:\nosc().out() Press the run button to run this code and update the visuals on the screen. You should see some scrolling stripes appear in the background.\nThis creates a visual oscillator. Try modifying the parameters of the oscillator by putting a number inside the parentheses of osc(), for example osc(10).out().\nRe-run the code by pressing the run button again, and seeing the visuals update. Try adding other values to control the oscillator\u0026rsquo;s frequency, sync, and color offset.\nTrick: you can also use the keyboard shortcut ‘ctrl + shift + enter’ to have the same effect as the run button.\nAdding transformations # We can add another transformation to the oscillator from above, by adding the function rotate() after the oscillator:\nAs you can see, you have first an input source osc() and things that come after (rotate() and out()) are connected with a dot ‘.’ In this sense, Hydra is inspired by modular synthesis. Instead of connecting cables you connect different kinds of javascript functions.\nsource Sandin Image Processor # You can continue adding transformations to this chain of functions. For example:\nRepeat:\nFor more available sources and transformations, see the interactive function reference. The logic is to start with a source (such as osc(), shape(), or noise()), and then add transformations to geometry and color (such as .rotate(), .kaleid(), .pixelate() ), and in the end always connect the chain of transformations to the output screen .out() .\nWhat is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. Save your sketch on the internet # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. Using the webcam # In addition to using sources from within hydra (such as osc() and shape()), you can use hydra to process external video sources such as a webcam. To initialize the webcam, run the following code:\ns0.initCam() This activates the webcam source inside a variable called s0, and you should see the light on your webcam light up. However, you will still not see the webcam image on the screen. In order to use the camera within a hydra sketch, you need to use it within the src() function.\nSimilar to adding transformations above, you can add transformations of color and geometry to the camera output, by adding functions to the chain:\nIf you have multiple webcams, you can access separate cameras by adding a number inside initCam, for example s0.initCam(1) or s0.initCam(2).\nMultiple outputs # By default, hydra contains four separate virtual outputs that can each render different visuals, and can be mixed with each other to create more complex visuals. The variables o0, o1, o2, and o3 correspond to the different outputs.\nTo see all four of the outputs at once, use the render() function. This will divide the screen into four, showing each output in a different section of the screen.\nUsing a different variable inside the .out() function renders the chain to a different output. For example, .out(o1) will render a function chain to graphics buffer o1.\nBy default, only output o0 is rendered to the screen, while the render() command divides the screen in four. Show a specific output on the screen by adding it inside of render(), for example render(o2) to show buffer o2.\nTrick: try to create different sketches and switch them in your live performance or even combine them.\nBlending multiple visual sources together # You can use blend functions to combine multiple visual sources. .blend() combines the colors from two sources to create a third source.\nTry adding transformations to the above sources (such as osc(10).rotate(0, 0.1).out(o1)) to see how it affects the combined image. You can also specify the amount of blending by adding a separate parameter to .blend(), for example .blend(o1, 0.9).\nThere are multiple blend modes in hydra, similar to blend modes you might find in a graphics program such as photoshop or gimp. See the function reference for more possibilities.\nModulation # While blend functions combine the colors from two visual sources, modulate functions use the colors from one source to affect the geometry of the second source. This creates a sort of warping or distorting effect. An analogy in the real world would be looking through a texture glass window. modulate() does not change color or luminosity but distorts one visual source using another visual source.\nUsing the same sources from above, we can use an oscillator to modulate or warp the camera image:\nYou can add a second parameter to the modulate() function to control the amount of warping: modulate(o1, 0.9). In this case, the red and green channels of the oscillator are being converted to x and y displacement of the camera image.\nAll geometry transformations have corresponding modulate functions that allow you to use one source to warp another source. For example, .modulateRotate() is similar to .rotate(), but it allows you to apply different amounts of rotation to different parts of the visual source. See the function reference for more examples.\nMore blending and modulating # In addition to using multiple outputs to combine visuals, you can also combine multiple sources within the same function chain, without rendering them to separate outputs.\nThis allows you to use many sources, blend modes, and modulation, all from within the same chain of functions.\nTrick: use ctrl + shift + f from the web editor to auto-format your code\nModulating with the camera # We have now covered all of the basic types of functions within hydra: source, geometry, color, blending, and modulation! See what you can come up with by mixing these together.\nHave fun! # "},{"id":6,"href":"/docs/docs/learning_old/getting-started/oscillator/","title":"Drawing an oscillator","section":"learning","content":" First line of code # Use the clear all button to erase the previous sketch.\nThen, type or paste the following in the editor:\nosc().out() Press the run button to run this code and update the visuals on the screen. You should see some scrolling stripes appear in the background. You can also edit the code directly on this page:\nThis creates a visual oscillator. Try modifying the parameters of the oscillator by putting a number inside the parentheses of osc(), for example osc(10).out().\nRe-run the code by pressing the run button again, and seeing the visuals update. Try adding other values to control the oscillator\u0026rsquo;s frequency, sync, and color offset.\nAn oscillator is a type of source in hydra. For a complete list of available sources, see the interactive function reference or the list of available sources. Trick: you can also use the keyboard shortcut ‘ctrl + shift + enter’ to have the same effect as the run button.\n"},{"id":7,"href":"/docs/docs/learning_tutorial/getting-started/oscillator/","title":"Drawing an oscillator","section":"Getting Started","content":" First line of code # Use the clear all button to erase the previous sketch.\nThen, type or paste the following in the editor:\nosc().out() Press the run button to run this code and update the visuals on the screen. You should see some scrolling stripes appear in the background. You can also edit the code directly on this page:\nThis creates a visual oscillator. Try modifying the parameters of the oscillator by putting a number inside the parentheses of osc(), for example osc(10).out().\nRe-run the code by pressing the run button again, and seeing the visuals update. Try adding other values to control the oscillator\u0026rsquo;s frequency, sync, and color offset.\nAn oscillator is a type of source in hydra. For a complete list of available sources, see the interactive function reference or the list of available sources. Trick: you can also use the keyboard shortcut ‘ctrl + shift + enter’ to have the same effect as the run button.\n"},{"id":8,"href":"/docs/docs/learning/","title":"learning","section":"Docs","content":" learning # getting started # step-by-step tutorial for starting to code with hydra\nweb editor # key commands, comments, saving sketches, loading extensions and external libraries, publishing to the gallery\nvideo synth basics # overview of hydra\u0026rsquo;s modular approach and main function types: sources, color, geometry, blending, and modulation\nexternal sources # using webcams, images, videos, html canvas elements, and live streams inside a hydra sketch\nsequencing # change values over time in your patches using arrays and arrow functions\ninteractivity # get external data to interact with your visuals such as your mouse position, audio or midi messages into hydra\nextending hydra # using hydra-synth extensions. incorporating other javascript libraries such as p5.js, THREE.js, Tone.js. writing your own GLSL functions. developing \u0026amp; contributing to the project.\nguides # deeper dives into hydra topics written by members of the community.\n"},{"id":9,"href":"/docs/docs/learning_old/reference/api/color/","title":"Color","section":"API","content":" Color # posterize # posterize( bins = 3, gamma = 0.6 )\nshift # shift( r = 0.5, g, b, a )\ninvert # invert( amount = 1 )\nInvert color.\ncontrast # contrast( amount = 1.6 )\nLarger amount value makes higher contrast.\nbrightness # brightness( amount = 0.4 )\nluma # luma( threshold = 0.5, tolerance = 0.1 )\nthresh # thresh( threshold = 0.5, tolerance = 0.04 )\ncolor # color( r = 1, g = 1, b = 1, a = 1 )\nsaturate # saturate( amount = 2 )\nhue # hue( hue = 0.4 )\ncolorama # colorama( amount = 0.005 )\nShift HSV values.\nsum # sum( scale = 1 )\nr # r( scale = 1, offset )\ng # g( scale = 1, offset )\nb # b( scale = 1, offset )\na # a( scale = 1, offset )\n"},{"id":10,"href":"/docs/docs/learning/getting-started/","title":"getting started","section":"learning","content":" Getting started with hydra # This document is an introduction to making live visuals using Hydra. It covers the basics of writing code in the browser to generate and mix live video sources. No coding or video experience is necessary!\nThis tutorial is meant to be used alongside the hydra web editor. It is also interactive \u0026ndash; you can directly modify the code in each code block to see how it affects the visuals.\nGet to know the browser editor # To get started, open the hydra web editor in a separate window. Close the top window by clicking the [x] in the top right.\nYou will see some colorful visuals in the background with text on top in the top left of the screen. The text is code that generates the visuals behind it.\nAt the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter). upload to gallery Upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL. clear all Resets the environment and clears text from the editor. show random sketch Loads random sketch examples. Always it is a good way to learn Hydra by studying someone else\u0026rsquo;s code. make random change dices Modifies a single value automatically. Try it with some of the sketch examples. show info window Show overlay window with help text and links. First line of code # Use the clear all button to erase the previous sketch.\nThen, type or paste the following in the editor:\nosc().out() Press the run button to run this code and update the visuals on the screen. You should see some scrolling stripes appear in the background.\nThis creates a visual oscillator. Try modifying the parameters of the oscillator by putting a number inside the parentheses of osc(), for example osc(10).out().\nRe-run the code by pressing the run button again, and seeing the visuals update. Try adding other values to control the oscillator\u0026rsquo;s frequency, sync, and color offset.\nTrick: you can also use the keyboard shortcut ‘ctrl + shift + enter’ to have the same effect as the run button.\nTransformations # We can add a transformation to the oscillator above, by adding a function such as rotate() after the oscillator:\nModularity # As you can see, you have first an input source osc() and things that come after (rotate() and out()) are connected with a dot ‘.’ In this sense, Hydra is inspired by modular synthesis. Instead of connecting modules with cables you connect different kinds of JavaScript functions using dots and calls.\nSource: Sandin Image Processor # You can continue adding transformations to this chain. For example:\nRepeat:\nFor more available sources and transformations, see the interactive function reference. The logic is to start with a source (such as osc(), shape(), or noise()), and then add transformations to geometry and color (such as .rotate(), .kaleid(), .pixelate() ), and in the end always connect the chain of transformations to the output screen .out() .\nCode concepts # What is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. Save your sketches # As a link # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. On the internet # You can use the upload button on the editor to upload your sketch to the hydra database. This is useful for sketches with longer code. Sketches and their screenshots are shared publicly on Mastodon. (NOTE: the Mastodon account isn\u0026rsquo;t working right now, so sketches aren\u0026rsquo;t shared).\nUsing the webcam # In addition to using sources from within hydra (such as osc() and shape()), you can use hydra to process external video sources such as a webcam. To initialize the webcam, run the following code:\ns0.initCam() This activates the webcam source inside a variable called s0, and you should see the light on your webcam light up. However, you will still not see the webcam image on the screen. In order to use the camera within a hydra sketch, you need to use it within the src() function.\nSimilar to adding transformations above, you can add transformations of color and geometry to the camera output, by adding functions to the chain:\nIf you have multiple webcams, you can access separate cameras by adding a number inside initCam, for example s0.initCam(1) or s0.initCam(2).\nMultiple outputs # By default, hydra contains four separate virtual outputs that can each render different visuals, and can be mixed with each other to create more complex visuals. The variables o0, o1, o2, and o3 correspond to the different outputs.\nTo see all four of the outputs at once, use the render() function. This will divide the screen into four, showing each output in a different section of the screen.\nUsing a different variable inside the .out() function renders the chain to a different output. For example, .out(o1) will render a function chain to graphics buffer o1.\nBy default, only output o0 is rendered to the screen, while the render() command divides the screen in four. Show a specific output on the screen by adding it inside of render(), for example render(o2) to show buffer o2.\nTrick: try to create different sketches and switch them in your live performance or even combine them.\nBlending textures together # You can use blend functions to combine multiple visual sources. .blend() combines the colors from two sources to create a third source.\nTry adding transformations to the above sources (such as osc(10).rotate(0, 0.1).out(o1)) to see how it affects the combined image. You can also specify the amount of blending by adding a separate parameter to .blend(), for example .blend(o1, 0.9).\nThere are multiple blend modes in hydra, similar to blend modes you might find in a graphics program such as photoshop or gimp. See the function reference for more possibilities.\nModulation # While blend functions combine the colors from two visual sources, modulate functions use the colors from one source to affect the geometry of the second source. This creates a sort of warping or distorting effect. An analogy in the real world would be looking through a texture glass window. modulate() does not change color or luminosity but distorts one visual source using another visual source.\nUsing the same sources from above, we can use an oscillator to modulate or warp the camera image:\nYou can add a second parameter to the modulate() function to control the amount of warping: modulate(o1, 0.9). In this case, the red and green channels of the oscillator are being converted to x and y displacement of the camera image.\nAll geometry transformations have corresponding modulate functions that allow you to use one source to warp another source. For example, .modulateRotate() is similar to .rotate(), but it allows you to apply different amounts of rotation to different parts of the visual source. See the function reference for more examples.\nMore blending and modulating # In addition to using multiple outputs to combine visuals, you can also combine multiple sources within the same function chain, without rendering them to separate outputs.\nThis allows you to use many sources, blend modes, and modulation, all from within the same chain of functions.\nTrick: use ctrl + shift + f from the web editor to auto-format your code\nModulating with the camera # We have now covered all of the basic types of functions within hydra: source, geometry, color, blending, and modulation! See what you can come up with by mixing these together.\nHave fun! # by Flor de Fuego and Olivia Jack\n"},{"id":11,"href":"/docs/docs/learning/web-editor/","title":"web editor","section":"learning","content":" web editor # Basic usage of the browser editor at hydra.ojack.xyz\nKeyboard shortcuts # CTRL-Enter: run a line of code CTRL-Shift-Enter: run all code on screen ALT-Enter: run a block CTRL-Shift-H: hide or show code CTRL-Shift-F: format code using Prettier CTRL-Shift-S: Save screenshot and download as local file. CTRL-Shift-G: Shares to Mastodon (not available right now, but you can still store sketches). Toolbar # At the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter) upload to gallery upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL clear all resets the environment and clears text from the editor show random sketch. Loads random sketch examples. Always it is a good way to learn Hydra by studying someone elses code. make random change dices modify values automatically. Try it with some of the sketch examples. show info window show overlay window with help text and links Save your sketches # As a link # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. On the internet # You can use the upload button on the editor to upload your sketch to the hydra database. This is useful for sketches with longer code. Sketches and their screenshots are shared publicly on Mastodon. (NOTE: the Mastodon account isn\u0026rsquo;t working right now, so sketches aren\u0026rsquo;t shared).\nShare hiding code by default # The showCode=false URL flag makes it possible to share a sketch with the code hidden.\nExample # Here\u0026rsquo;s a patch and its URL:\nosc(10, 0.1, 1.2).modulateScale(noise(3)).out() https://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D We can easily share the same sketch, but with the code and toolbar hidden by adding \u0026amp;showCode=false at the end:\nhttps://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D\u0026amp;showCode=false Pressing Ctrl+Shift+H will show the code again.\nWhat is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. By Flor de Fuego, Olivia Jack\n"},{"id":12,"href":"/docs/docs/learning_old/getting-started/geometry-and-color/","title":"Geometry and color","section":"learning","content":" Adding transformations # We can add another transformation to the oscillator from above, by adding the function rotate() after the oscillator:\nAs you can see, you have first an input source osc() and things that come after (rotate() and out()) are connected with a dot ‘.’ In this sense, Hydra is inspired by modular synthesis. Instead of connecting cables you connect different kinds of javascript functions.\nsource Sandin Image Processor # You can continue adding transformations to this chain of functions. For example:\nRepeat:\nFor more available sources and transformations, see the interactive function reference. The logic is to start with a source (such as osc(), shape(), or noise()), and then add transformations to geometry and color (such as .rotate(), .kaleid(), .pixelate() ), and in the end always connect the chain of transformations to the output screen .out() .\nWhat is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. Save your sketch on the internet # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. "},{"id":13,"href":"/docs/docs/learning_tutorial/getting-started/geometry-and-color/","title":"Geometry and color","section":"Getting Started","content":" Adding transformations # We can add another transformation to the oscillator from above, by adding the function rotate() after the oscillator:\nAs you can see, you have first an input source osc() and things that come after (rotate() and out()) are connected with a dot ‘.’ In this sense, Hydra is inspired by modular synthesis. Instead of connecting cables you connect different kinds of javascript functions.\nsource Sandin Image Processor # You can continue adding transformations to this chain of functions. For example:\nRepeat:\nFor more available sources and transformations, see the interactive function reference. The logic is to start with a source (such as osc(), shape(), or noise()), and then add transformations to geometry and color (such as .rotate(), .kaleid(), .pixelate() ), and in the end always connect the chain of transformations to the output screen .out() .\nWhat is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. Save your sketch on the internet # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. "},{"id":14,"href":"/docs/docs/reference/","title":"reference","section":"Docs","content":""},{"id":15,"href":"/docs/docs/learning/video-synth-basics/","title":"video synth basics","section":"learning","content":" video synth basics # Modularity # Hydra is inspired by modular synthesis. Instead of connecting modules with cables you connect different kinds of JavaScript functions using dots and calls. Numeric arguments inside functions are analogue to the position of knobs in modules.\nsource Sandin Image Processor # The logic is to start with a source (such as osc(), shape(), or noise()), and then add transformations to geometry and color (such as .rotate(), .kaleid(), .pixelate() ), and in the end always connect the chain of transformations to the output screen .out() .\nFor example, the following code renders an oscillator with parameters frequency, sync, and RGB offset:\nWe can add another transformation to the oscillator from above, by adding the function rotate() after the oscillator:\nWe can expand the patch, pixelating the output of the above function:\nFunction glossary # See the interactive function reference for a glossary of all the functions.\n"},{"id":16,"href":"/docs/docs/learning/external-sources/","title":"external sources","section":"learning","content":" external sources # Hydra allows you to load external image sources easily using different browser functionalities. Some of the possible internal sources are: static images, videos, webcam, screen-sharing, and other possibilities. You load each of these to the different source variables (s0, s1, s2 and s3), which can be used in the same way outputs can via the usage of the src function. Sources need to be initialized with some key info in order to work. We do this by calling an init function on them. You\u0026rsquo;ll see them in action below.\nwebcam # initCam # We can activate the webcam inside a source variable using the initCam function. When run, you should see the light on your webcam light up. However, you will still not see any image on the screen. You need to use it within the src() function to access the video signal. If you have multiple webcams, you can access each camera by indicating an index number inside initCam, for example s0.initCam(1) or s0.initCam(2).\ns0.initCam( index = 0, params )\nYou can add transformations of color and geometry to these just as any other source:\nimages # initImage # Load an image into a source object:\ns0.initImage( url = \u0026quot;\u0026quot;, params )\nUsage in pulsar # When running Hydra inside Pulsar, or any other local manner, you can load local files referring to them by URI:\ns0.initImage(\u0026#34;file:///home/user/Images/image.png\u0026#34;) Supported image formats # You can load .jpeg, .png, and .bmp as well as .gif and .webp (although webp animation won\u0026rsquo;t work).\nvideos # initVideo # Loading videos is extremely similar to loading an image, you just need to use the initVideo function.\ns0.initVideo( url = \u0026quot;\u0026quot;, params )\nSupported video formats # You can load .mp4, .ogg and .webm videos.\nHTML Video properties # You can access all of the HTML Video functions when a video is loaded to a Source via s0.src. Some useful properties are:\ns0.src.playbackRate = 2 // double the speed at which the video plays s0.src.currentTime = 10 // seek to the 10th second s0.src.loop = false // don\u0026#39;t loop the video Loading videos from YouTube, Vimeo, etc # Some users may be tempted to try and load some video they liked on YouTube, for example, and run something suchlike:\ns0.initVideo(\u0026#39;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#39;) // doesn\u0026#39;t work This will not work. The same goes for Vimeo and other video streaming services. When you use such an URL, it is not returning a video, it is returning the website where you can watch the video! The URL you pass to initVideo has to go directly to a video file. In other words, the URL should (usually) end in .mp4, .webm or .ogg. And, even if you did get a URL directly to the video with a tool such as youtube-dl, you\u0026rsquo;ll run into CORS problems.\nWorkaround # The most common workarounds are:\nRun Hydra locally (on Atom for example) and load local video files Have the video run on its own window and use initScreen to capture it Run a local file server Tutorial # screen sharing # initScreen # You can also use the screen-sharing capabilities of most modern browsers as a video source. It works in the same way sharing your screen on video conferences work!\ns0.initScreen( params )\nTutorial # canvas (HTML) # init # This is a more generic function for loading any external source into hydra. This is especially useful when you are using an HTML canvas element as an input, or loading an existing resource as a source into hydra. Valid input types are documented in the regl texture documentation.\ns0.init( opts, params )\nDynamic inputs # Use the dynamic parameter to indicate whether the source will be updated, or remain static!\ns0.init({src: animatedCanvas, dynamic: true}) s1.init({src: staticImageCanvas, dynamic: false}) streaming # note: initStream() is currently broken in hydra editor due to server issues initStream # The Hydra editor also has built-in streaming. You can stream the output of your Hydra to someone else using Hydra and vice-versa. This is done in a similar fashion to using images and videos, using external sources. Everyone using Hydra has a session, of which they can set the name. Streaming-in video from someone else into your patches is as simple as initiating and passing the name of the session you want to see. Streaming-out your Hydra to someone else requires you to set the name of your session and share it with someone else.\ns0.initStream( streamName, params )\n// naming my session so he can use it pb.setName(\u0026#39;myverycoolsession\u0026#39;) // loading my friend\u0026#39;s session s0.initStream(\u0026#39;myfriendsverycoolsession\u0026#39;) src(s0) .out() The pb object # On your Hydra editor, you can find a pre-defined object called pb (as in patch-bay). This object basically represents the connection of your Hydra editor instance to all others hosted on the same server. When you want to share your stream to someone else you\u0026rsquo;ll have to give your Hydra session a name. Do this using the pb.setName() function and by passing in some string as the name. For example: pb.setName('myverycoolsession'). If you want someone else to stream to you, ask them to set a name as such and share it with you. You can see online sessions using the function pb.list(), which will return an Array of names.\nparams # Any external sources loaded into Hydra are using regl\u0026rsquo;s texture constructor in the background. There are many properties you can set when loading a texture, Hydra and regl handle the important ones for you. To set any of these properties yourself you can pass an object containing them to any of the init functions. For example:\ns0.initCam(0,{mag: \u0026#39;linear\u0026#39;}) mag \u0026amp; min are the most used parameters, since using linear interpolation will resize textures in a smooth way. The default for both is nearest.\nCORS problems # If you try to load images (or videos) from some websites (most of them, really), sometimes nothing shows up on the screen. Opening the browser\u0026rsquo;s console might reveal a message similar to this one:\nAccess to image at \u0026#39;...\u0026#39; from origin \u0026#39;https://hydra.ojack.xyz\u0026#39; has been blocked by CORS policy: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. The CORS in CORS policy stands for \u0026lsquo;Cross-origin resource sharing\u0026rsquo;. This refers to the action of calling resources (such as images) from one website to another. For example, asking for an image hosted on other website from inside the Hydra editor. This error message is basically telling us \u0026ldquo;hey, the website you\u0026rsquo;re trying to ask for an image doesn\u0026rsquo;t allow other websites to use their resources, so I can\u0026rsquo;t let you have that picture\u0026rdquo;.\nIn order to circumvent this error, you can try re-uploading the images you want to use to some image hosting service that allows cross-origin sharing such as imgur, where you can also load short videos. You can also run a local server for your files. There are also some sites which allow cross-origin resource sharing such as Wikimedia Commons, which is great for video.\n"},{"id":17,"href":"/docs/posts/hello-world/","title":"Brand new hydra blog and documentation portal","section":"blog","content":"WIP portal for hydra video synth. This will be a home for news and updates regarding hydra, as well as a hub for community resources and documentaiton.\nFor the main hydra website, see the web editor.\nWe welcome contributions!\n"},{"id":18,"href":"/docs/docs/learning_old/reference/api/external-sources/","title":"External sources","section":"API","content":" External Sources # Using the webcam # In addition to using sources from within hydra (such as osc() and shape()), you can use hydra to process external video sources such as a webcam. External sources in hydra are referenced using predefined objects s0, s1, s2, and s3. To initialize the webcam in s0, run the following code:\ns0.initCam() This activates the webcam source inside a variable called s0, and you should see the light on your webcam light up. However, you will still not see the webcam image on the screen. In order to use the camera within a hydra sketch, you need to use it within the src() function.\nSimilar to adding transformations above, you can add transformations of color and geometry to the camera output, by adding functions to the chain:\nIf you have multiple webcams, you can access separate cameras by adding a number inside initCam, for example s0.initCam(1) or s0.initCam(2).\nAvailable source functions # initCam() # You can use a webcam\u0026rsquo;s video as such:\ns0.initCam() s0.initCam(2) // if you have many cameras, you can select one specifically initImage() # Load an image into a source object:\n// load an image into a source object s0.initImage(\u0026#34;https://upload.wikimedia.org/wikipedia/commons/2/25/Hydra-Foto.jpg\u0026#34;) // show the image on the screen src(s0).out() When running Hydra in Atom, or any other local manner, you can load local files referring to them by URI:\ns0.initImage(\u0026#34;file:///home/user/Images/image.png\u0026#34;) Supported image formats # You can load .jpeg, .png, and .bmp as well as .gif and .webp (although animation won\u0026rsquo;t work).\ninitVideo() # The syntax for loading video is the same as for loading image, only changing the function to loadVideo:\ns0.initVideo(\u0026#34;https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\u0026#34;) src(s0).out() Supported video formats # You can load .mp4, .ogg and .webm videos.\nUseful HTML Video properties # You can access all of the HTML Video functions when a video is loaded to a Source via s0.src. Some useful properties are:\ns0.src.playbackRate = 2 // double the speed at which the video plays s0.src.currentTime = 10 // seek to the 10th second s0.src.loop = false // don\u0026#39;t loop the video initScreen() # You can capture your screen or specific windows or tabs to use as a video source:\ns0.initScreen() src(s0).out() init() # init() is a more generic function for loading any external source into hydra. This can be especially useful when you are using an HTML canvas element as an input, or loading an existing resource as a source into hydra. Valid input types are documented in the regl texture documentation.\nFor example, the following code creates a canvas element and draws text to it, and then uses that canvas as a source in hydra:\nuse the dynamic parameter to indicate whether the source will be updated, or remain the same.\ninitStream() # note: initStream() is currently broken in hydra editor due to server issues streaming between Hydra sessions\nHydra (the editor) also has built-in streaming. You can stream the output of your Hydra to someone else and vice-versa. This is done in a similar fashion to using images and videos, using external sources. But there are some extra steps for streaming:\nThe pb object # On your Hydra editor, you can find a pre-defined object called pb (as in patch-bay). This object basically represents the connection of your Hydra editor instance to all others hosted on the same server. When you want to share your stream to someone else you\u0026rsquo;ll have to give your Hydra session a name. Do this using the pb.setName() function and by passing in some string as the name. For example: pb.setName('myverycoolsession'). If you want someone else to stream to you, ask them to set a name as such and share it with you.\nYou can see online sessions using the function pb.list(), which will return an Array of names.\nStarting to stream # Streaming is as simple as initiating the source as a stream and passing the name of the session you want to stream. For example:\ns0.initStream(\u0026#39;myfriendsverycoolsession\u0026#39;) src(s0) .out() Extra parameters # Any external sources loaded into Hydra are using regl\u0026rsquo;s texture constructor in the background. There are many properties you can set when loading a texture and Hydra and regl handle the important ones for you. But to set any of these properties you can pass an object containing them to any of the init functions. For example:\ns0.initCam(0,{mag: \u0026#39;linear\u0026#39;}) mag \u0026amp; min are the most used, since using linear interpolation will resize textures in a smooth way. The default for both is nearest.\nCommon problems # CORS policy # If you try to load images (or videos) from some websites (most of them, really), sometimes nothing shows up on the screen. Opening the browser\u0026rsquo;s console might reveal a message similar to this one:\nAccess to image at \u0026#39;...\u0026#39; from origin \u0026#39;https://hydra.ojack.xyz\u0026#39; has been blocked by CORS policy: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. The CORS in CORS policy stands for \u0026lsquo;Cross-origin resource sharing\u0026rsquo;. This refers to the action of calling resources (such as images) from one website to another. For example, asking for an image hosted on other website from inside the Hydra editor. This error message is basically telling us \u0026ldquo;hey, the website you\u0026rsquo;re trying to ask for an image doesn\u0026rsquo;t allow other websites to use their resources, so i can\u0026rsquo;t let you have that picture\u0026rdquo;. In order to circumvent this error, you can try re-uploading the images you want to use to some image hosting service that allows cross-origin sharing such as imgur, where you can also load short videos. You can also try to use websites which you know will allow cross-origin resource sharing such as Wikimedia Commons, which is great for video.\nLoading video from YouTube, Vimeo, etc # Some users may be tempted to try and load some video they liked on YouTube, for example, and run something suchlike:\ns0.initVideo(\u0026#39;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#39;) // doesn\u0026#39;t work This will not work. The same goes for Vimeo and other video streaming services. When you use such an URL, it is not returning a video, it is returning the website where you can watch the video! The URL you pass to initVideo has to go directly to a video file. In other words, the URL should (usually) end in .mp4, .webm or .ogg. And, even if you did get a URL directly to the video with a tool such as youtube-dl, you\u0026rsquo;ll run into CORS problems.\nWorkaround # The most common workarounds are:\nRun Hydra locally (on Atom for example) and load local video files Have the video run on its own window and use initScreen to capture it "},{"id":19,"href":"/docs/docs/learning_tutorial/guides/guides/textures/","title":"Hydra Book: Textures","section":"Guides","content":" Textures # by Naoto Hieda\nIn this chapter, we discuss textures or patterns, separately from colors or movements. Most of the snippets have low saturation in order to separate textures from other effects.\nOscillator # osc(freq,sync,offset) is one of the basic sources to create a texture. The first argument determines the frequency (i.e., how packed the stripes are), the second for the sync (i.e., the scroll speed), and the third for the offset, which adds color to the pattern. One cycle of an oscillator in the screen space can be achieved by osc(Math.PI * 2); thus the following example shows 10 cycles:\nFor simplicity, natural numbers are often used as freq or the first argument (e.g., osc(40,0)). The sync parameter is multiplied with time and freq; thus even if sync is unchanged, the larger the frequency, the faster the scroll speed (discussed in motions). offset cycles from 0 to PI*2, which shifts the color.\nBy adding thresh() or posterize(), the oscillator pattern becomes clear stripes. thresh(threshold) literally thresholds the grayscale value; if the pixel\u0026rsquo;s grayscale is brighter than threshold, returns white and else returns black (alpha is preserved). posterize(bins,gamma) thresholds with multiple steps, similar to histogram. pixelate() achieves a similar effect; however, the offset between the bumps of the oscillator and the pixelation bins can create artifacts.\n(render() displays four buffers; o0 on top left, o1 on bottom left, o2 on top right and o3 on bottom right)\nkaleid() with a large number creates circles,\n99 is a magic number; to save character counts (which is essential for live coding), 99 is big enough and only takes 2 characters. However, depending on the effect you want to create, you might need to set a higher number, such as 999, or 1e4.\nYou might have noticed that this sketch is stretched if the window is not square. scale(amount,x,y) can correct the scaling; it scales amount*x to x-axis and amount*y to y-axis. Therefore, scale(1,1,16/9) fits the sketch to 16:9 window, and in general,\nscale(1,1,()=\u0026gt;window.innerWidth/window.innerHeight) adapts the sketch to any size of the window. Notice ()=\u0026gt;, which is an arrow function. If a value is passed to a hydra function (e.g., scale(1,1,window.innerWidth/window.innerHeight)), it will be evaluated only once when ctrl+enter or ctrl+shift+enter is pressed. However, an arrow function is evaluated every frame; thus, it becomes responsive to the window size change. In the rest of the book, a square window is assumed for simplicity. Note that width and height global variables are set when the hydra canvas is initialized, and they will not change according to window resizing.\nkaleid with a small number creates a geometric shape (in the example, an oscillator is combined with kaleid and thresh).\nNoise # noise() is another basic function as a source. A texture is generated based on a variant of Perlin Noise.\nWe will look more into detail in the modulator and arithmetic sections.\nVoronoi # voronoi() is a source to generate a Voronoi diagram.\nShapes # shape(sides,radius,smoothing) generates a polygon with a number of sides set by sides. Nevertheless, it is more than just a polygon - radius changes the size of the shape, and most importantly, smoothing sets gradient of the shape; 1 for fuzzy borders and close to 0 for sharp edges (however, setting to 0 does not work in recent versions). For example, shape(2) is a thick line, which can be scaled to make a thin line.\nor simply,\nBy repeating shape(4) and overlapping them, it gives a grid-like pattern. For convenience, a parameter and a function are stored in JavaScript variables.\nSimilar to kaleid(), shape() with a large number of sides creates a circle. By tweaking the example above, it generates a Polka dot pattern.\nor almost equivalent with (the center of the image will be horizontally shifted)\nThis tiling technique can be used to create a RGB pixel filter. In this example, func is decomposed into R, G, and B channels and overlaid on top of each other.\nScaling # Scaling and difference can also create a periodic texture.\nThis technique can also be applied to a complex texture.\nThe effect can be enhanced by thresh and setting the third argument of voronoi to 0, to have sharp edges. However, a naive implementation will end up in a complete noise (notice that thresh(threshold, tolerance)\u0026rsquo;s tolerance has to be always bigger than 0).\nTo have a desired effect, apply a square mask (before trying the next example, apply solid().out(o0) to clear the buffer).\nThis example can be used together with rotation.\nOr, instead of scale, scrolling functions (scrollX and scrollY) can be used with a feedback loop.\n"},{"id":20,"href":"/docs/docs/learning_tutorial/next-steps/interactivity/","title":"Interactivity: mouse, audio, and MIDI","section":"Next Steps","content":" Interactivity: mouse, audio, and MIDI # Custom functions are especially useful for controlling hydra parameters using external inputs, such as the microphone, mouse, or midi control.\nMouse interactivity # Hydra visuals can react to the position of your mouse (or finger, in touch devices). Hydra has an object called mouse which stores and keeps track of the position of your mouse on the webpage.\nmouse.x \u0026amp; mouse.y # | You can refer to the pixel position of your mouse by calling mouse.x and mouse.y, each one corresponding to the horizontal and vertical coordinates respectively. When we say \u0026lsquo;pixel position\u0026rsquo;, this means that the values you\u0026rsquo;ll find stored in both x and y are represented in pixels. So for mouse.x, this means the amount of pixels from the left edge of your window to the position of your mouse. For mouse.y, this means the amount of pixels between the top end of your screen and the position of your mouse.\nMany times it will be most useful to use values relative to the size of the screen. And also to have values that exist between ranges more reasonable to the hydra functions you\u0026rsquo;re using. For example [-0.5; 0.5] for scrollX and scrollY, [0; 2pi] for rotation, or [0; 1] for general purposes.\nNote # All of the examples using mouse position to move stuff on the canvas won\u0026rsquo;t work well here, since the canvas doesn\u0026rsquo;t occupy the full size of the screen as in the editor. Take this into account when we use mouse, that the positions are relative to the full webpage and not the canvas. This also means that as you scroll down this guide the y value will get higher and higher.\nControl anything with your mouse # On Hydra, most values used are pretty small. So it will be way more useful to have the position of the mouse as values from 0 and 1:\nGetting values from 0 to 1 # You can simply multiply by 2*Math.PI to change the range to [0; 2pi]\nMake something follow your mouse # On Hydra, things are placed between 0.5 and -0.5 (left to right, top to bottom). In order for anything to follow your mouse, you\u0026rsquo;ll need to get the position of your mouse between that range:\nGetting values from 0 to ±0.5 from the center # Remember you can name these functions however you prefer.\nThe time variable seen there is a variable pre-declared by Hydra, that stores how much time passed since Hydra started in seconds.\nFunctions used in Hydra don\u0026rsquo;t need to be arrow functions, any no-argument function will do! Make sure your function is returning a Number to avoid errors.\nThe time variable # When you use functions that can take numerical arguments, time will allow you to have their values evolve through\u0026hellip; time. If you multiply time by some value it\u0026rsquo;s as if time goes faster, while dividing while act as making time go slower. For example Math.sin(time*4) will go 4 times faster than Math.sin(time).\nThose users more familiar with mathematics might see this as:\ny(t) = t : ()=\u0026gt;time y(t) = A sin(f t + ph) : ()=\u0026gt;amplitude*Math.sin(freq*time + phase) We recommend getting familiar with some of the methods in the JS built-in Math object. Learn more about it here\n"},{"id":21,"href":"/docs/docs/learning_old/interactivity/","title":"Sequencing \u0026 interactivity","section":"learning","content":" Sequencing and Interactivity # by geikha and olivia\nIf you\u0026rsquo;re coding in Hydra, you\u0026rsquo;re constantly trying many values to input to the sources and transforms, and it\u0026rsquo;s just a matter of time until you like how more than one looks, and you want to somehow switch between them. We\u0026rsquo;ll be referring to this idea of arguments whose value change over time as dynamic arguments. And there are two main ways to achieve this in Hydra: Arrays and functions.\nSequencing using Arrays # Sequence your inputs # When you send an Array as an input (indicated in javascript by []), Hydra will automatically switch and jump from each element from the Array to the next one. When there are no more elements, it wraps all the way back to the beginning. Let\u0026rsquo;s see it in action:\nchanging the speed # The arrays in hydra have a default bpm(beats-per-minute) of 30. You can change the speed of a specific array by adding .fast() at the end of the array. For example .fast(4) will make the above array run four times faster.\nThe speed of all arrays in a sketch can be changed using the bpm parameter of hydra synth.\nbpm = 60 smooth() interpolation # You can also interpolate between values instead of jumping from one to the other. That is, smoothly transition between values. For this you can use the .smooth method. It may take a Number argument (defaulted to 1) which controls the smoothness.\nCustom Functions # Each numerical parameter in hydra can be defined as a function rather than a static variable. For example,\nosc(function(){return 100 * Math.sin(time * 0.1)}).out() modifies the oscillator frequency as a function of time. (Time is a global variable that represents the milliseconds that have passed since loading the page).\nThe above example can be written more concisely using es6 syntax:\nosc(() =\u0026gt; 100 * Math.sin(time * 0.1)).out() Custom functions are especially useful for controlling hydra parameters using external inputs, such as the microphone, mouse, or midi control.\nMouse interactivity # You can have your visuals react to the position of your mouse (or finger, in touch devices). Hydra has an object called mouse which stores and keeps track of the position of your mouse on the webpage.\nmouse.x \u0026amp; mouse.y # | You can refer to the pixel position of your mouse by calling mouse.x and mouse.y, each one corresponding to the horizontal and vertical coordinates respectively. When we say \u0026lsquo;pixel position\u0026rsquo;, this means that the values you\u0026rsquo;ll find stored in both x and y are represented in pixels. So for mouse.x, this means the amount of pixels from the left edge of your window to the position of your mouse. For mouse.y, this means the amount of pixels between the top end of your screen and the position of your mouse.\nMany times it will be most useful to use values relative to the size of the screen. And also to have values that exist between ranges more reasonable to the hydra functions you\u0026rsquo;re using. For example [-0.5; 0.5] for scrollX and scrollY, [0; 2pi] for rotation, or [0; 1] for general purposes.\nNote # All of the examples using mouse position to move stuff on the canvas won\u0026rsquo;t work well here, since the canvas doesn\u0026rsquo;t occupy the full size of the screen as in the editor. Take this into account when we use mouse, that the positions are relative to the full webpage and not the canvas. This also means that as you scroll down this guide the y value will get higher and higher.\nControl anything with your mouse # On Hydra, most values used are pretty small. So it will be way more useful to have the position of the mouse as values from 0 and 1:\nGetting values from 0 to 1 # You can simply multiply by 2*Math.PI to change the range to [0; 2pi]\nMake something follow your mouse # On Hydra, things are placed between 0.5 and -0.5 (left to right, top to bottom). In order for anything to follow your mouse, you\u0026rsquo;ll need to get the position of your mouse between that range:\nGetting values from 0 to ±0.5 from the center # Remember you can name these functions however you prefer.\nThe time variable seen there is a variable pre-declared by Hydra, that stores how much time passed since Hydra started in seconds.\nFunctions used in Hydra don\u0026rsquo;t need to be arrow functions, any no-argument function will do! Make sure your function is returning a Number to avoid errors.\nThe time variable # When you use functions that can take numerical arguments, time will allow you to have their values evolve through\u0026hellip; time. If you multiply time by some value it\u0026rsquo;s as if time goes faster, while dividing while act as making time go slower. For example Math.sin(time*4) will go 4 times faster than Math.sin(time).\nThose users more familiar with mathematics might see this as:\ny(t) = t : ()=\u0026gt;time y(t) = A sin(f t + ph) : ()=\u0026gt;amplitude*Math.sin(freq*time + phase) We recommend getting familiar with some of the methods in the JS built-in Math object. Learn more about it here\n"},{"id":22,"href":"/docs/docs/learning_tutorial/guides/how-to/","title":"How to","section":"More Resources","content":" how-to # record hydra output Embed hydra in a website Route audio Use hydra offline in atom Publish an extension Contribute to documentation Contribute to hydra code repository Record a video "},{"id":23,"href":"/docs/docs/learning/sequencing/","title":"sequencing","section":"learning","content":" sequencing # Hydra allows you to use dynamic inputs. So, anywhere you would write a number on a function, be it a source or a transform, you can make that value change other time. These changes through time can be one of both:\narrays # Arrays are lists of numbers. Passing them as arguments in functions will create strict periodical sequences. Hydra will automatically go from one value to the next and wrap around when finished over and over. Read more about them on the array page.\narrow functions # You can create functions of time and pass them as arguments. When you pass a function as an argument, Hydra will evaluate it each frame and use its return as the value during the next frame. Read more about this on the arrow functions page.\n"},{"id":24,"href":"/docs/docs/learning_old/getting-started/webcam/","title":"Webcam and video inputs","section":"learning","content":" Using the webcam # In addition to using sources from within hydra (such as osc() and shape()), you can use hydra to process external video sources such as a webcam, video, or screen capture. To initialize the webcam, run the following code:\ns0.initCam() This activates the webcam source inside a variable called s0, and you should see the light on your webcam light up. However, you will still not see the webcam image on the screen. In order to use the camera within a hydra sketch, you need to use it within the src() function.\nSimilar to adding transformations above, you can add transformations of color and geometry to the camera output, by adding functions to the chain:\nIf you have multiple webcams, you can access separate cameras by adding a number inside initCam, for example s0.initCam(1) or s0.initCam(2).\nSimilar to using the camera as an input, you can also use window or desktop capture, video sources, images, or HTML canvas elements as sources within Hydra. For a complete list of sources, see reference: external sources.\n"},{"id":25,"href":"/docs/docs/learning_tutorial/getting-started/webcam/","title":"Webcam and video inputs","section":"Getting Started","content":" Using the webcam # In addition to using sources from within hydra (such as osc() and shape()), you can use hydra to process external video sources such as a webcam, video, or screen capture. To initialize the webcam, run the following code:\ns0.initCam() This activates the webcam source inside a variable called s0, and you should see the light on your webcam light up. However, you will still not see the webcam image on the screen. In order to use the camera within a hydra sketch, you need to use it within the src() function.\nSimilar to adding transformations above, you can add transformations of color and geometry to the camera output, by adding functions to the chain:\nIf you have multiple webcams, you can access separate cameras by adding a number inside initCam, for example s0.initCam(1) or s0.initCam(2).\nSimilar to using the camera as an input, you can also use window or desktop capture, video sources, images, or HTML canvas elements as sources within Hydra. For a complete list of sources, see reference: external sources.\n"},{"id":26,"href":"/docs/docs/learning_old/reference/web-editor/","title":"using the web editor","section":"learning","content":" Web editor # basics of the browser editor at https://hydra.ojack.xyz\nkey commands # CTRL-Enter: run a line of code CTRL-Shift-Enter: run all code on screen ALT-Enter: run a block CTRL-Shift-H: hide or show code CTRL-Shift-F: format code using Prettier CTRL-Shift-S: Save screenshot and download as local file. The CTRL-Shift-G: Share to twitter (if available). Shares to @hydra_patterns toolbar # At the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter) upload to gallery upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL clear all resets the environment and clears text from the editor show random sketch. Loads random sketch examples. Always it is a good way to learn Hydra by studying someone elses code. make random change dices modify values automatically. Try it with some of the sketch examples. show info window show overlay window with help text and links share your sketch # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. sharing with the code hidden # The showCode=false url flag makes it possible to share a sketch with the code hidden.\nFor example, the following sketch\nosc(10, 0.1, 1.2).modulateScale(noise(3)).out() is available at the URL https://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D\nthis URL will correspond to the same sketch, but with the code and toolbar hidden: https://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D\u0026showCode=false\npressing Ctrl+Shift+h will show the code again\nWhat is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. "},{"id":27,"href":"/docs/docs/learning_old/video-synth-basics/web-editor/","title":"using the web editor","section":"learning","content":" Web editor # basics of the browser editor at https://hydra.ojack.xyz\nkey commands # CTRL-Enter: run a line of code CTRL-Shift-Enter: run all code on screen ALT-Enter: run a block CTRL-Shift-H: hide or show code CTRL-Shift-F: format code using Prettier CTRL-Shift-S: Save screenshot and download as local file. The CTRL-Shift-G: Share to twitter (if available). Shares to @hydra_patterns toolbar # At the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter) upload to gallery upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL clear all resets the environment and clears text from the editor show random sketch. Loads random sketch examples. Always it is a good way to learn Hydra by studying someone elses code. make random change dices modify values automatically. Try it with some of the sketch examples. show info window show overlay window with help text and links share your sketch # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. sharing with the code hidden # The showCode=false url flag makes it possible to share a sketch with the code hidden.\nFor example, the following sketch\nosc(10, 0.1, 1.2).modulateScale(noise(3)).out() is available at the URL https://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D\nthis URL will correspond to the same sketch, but with the code and toolbar hidden: https://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D\u0026showCode=false\npressing Ctrl+Shift+h will show the code again\n"},{"id":28,"href":"/docs/docs/learning_old/getting-started/blending/","title":"Combining visuals using blending and modulation","section":"learning","content":" Combining visuals using blending and modulation # Multiple outputs # By default, hydra contains four separate virtual outputs that can each render different visuals, and can be mixed with each other to create more complex visuals. The variables o0, o1, o2, and o3 correspond to the different outputs.\nTo see all four of the outputs at once, use the render() function. This will divide the screen into four, showing each output in a different section of the screen.\nUsing a different variable inside the .out() function renders the chain to a different output. For example, .out(o1) will render a function chain to graphics buffer o1.\nBy default, only output o0 is rendered to the screen, while the render() command divides the screen in four. Show a specific output on the screen by adding it inside of render(), for example render(o2) to show buffer o2.\nTrick: try to create different sketches and switch them in your live performance or even combine them.\nBlending multiple visual sources together # You can use blend functions to combine multiple visual sources. .blend() combines the colors from two sources to create a third source.\nTry adding transformations to the above sources (such as osc(10).rotate(0, 0.1).out(o1)) to see how it affects the combined image. You can also specify the amount of blending by adding a separate parameter to .blend(), for example .blend(o1, 0.9).\nThere are multiple blend modes in hydra, similar to blend modes you might find in a graphics program such as photoshop or gimp. See the function reference for more possibilities.\nModulation # While blend functions combine the colors from two visual sources, modulate functions use the colors from one source to affect the geometry of the second source. This creates a sort of warping or distorting effect. An analogy in the real world would be looking through a texture glass window. modulate() does not change color or luminosity but distorts one visual source using another visual source.\nUsing the same sources from above, we can use an oscillator to modulate or warp the camera image:\nYou can add a second parameter to the modulate() function to control the amount of warping: modulate(o1, 0.9). In this case, the red and green channels of the oscillator are being converted to x and y displacement of the camera image.\nAll geometry transformations have corresponding modulate functions that allow you to use one source to warp another source. For example, .modulateRotate() is similar to .rotate(), but it allows you to apply different amounts of rotation to different parts of the visual source. See the function reference for more examples.\nMore blending and modulating # In addition to using multiple outputs to combine visuals, you can also combine multiple sources within the same function chain, without rendering them to separate outputs.\nThis allows you to use many sources, blend modes, and modulation, all from within the same chain of functions.\nTrick: use ctrl + shift + f from the web editor to auto-format your code\nModulating with the camera # We have now covered all of the basic types of functions within hydra: source, geometry, color, blending, and modulation! See what you can come up with by mixing these together.\nHave fun! # "},{"id":29,"href":"/docs/docs/learning_tutorial/getting-started/blending/","title":"Combining visuals using blending and modulation","section":"Getting Started","content":" Combining visuals using blending and modulation # Multiple outputs # By default, hydra contains four separate virtual outputs that can each render different visuals, and can be mixed with each other to create more complex visuals. The variables o0, o1, o2, and o3 correspond to the different outputs.\nTo see all four of the outputs at once, use the render() function. This will divide the screen into four, showing each output in a different section of the screen.\nUsing a different variable inside the .out() function renders the chain to a different output. For example, .out(o1) will render a function chain to graphics buffer o1.\nBy default, only output o0 is rendered to the screen, while the render() command divides the screen in four. Show a specific output on the screen by adding it inside of render(), for example render(o2) to show buffer o2.\nTrick: try to create different sketches and switch them in your live performance or even combine them.\nBlending multiple visual sources together # You can use blend functions to combine multiple visual sources. .blend() combines the colors from two sources to create a third source.\nTry adding transformations to the above sources (such as osc(10).rotate(0, 0.1).out(o1)) to see how it affects the combined image. You can also specify the amount of blending by adding a separate parameter to .blend(), for example .blend(o1, 0.9).\nThere are multiple blend modes in hydra, similar to blend modes you might find in a graphics program such as photoshop or gimp. See the function reference for more possibilities.\nModulation # While blend functions combine the colors from two visual sources, modulate functions use the colors from one source to affect the geometry of the second source. This creates a sort of warping or distorting effect. An analogy in the real world would be looking through a texture glass window. modulate() does not change color or luminosity but distorts one visual source using another visual source.\nUsing the same sources from above, we can use an oscillator to modulate or warp the camera image:\nYou can add a second parameter to the modulate() function to control the amount of warping: modulate(o1, 0.9). In this case, the red and green channels of the oscillator are being converted to x and y displacement of the camera image.\nAll geometry transformations have corresponding modulate functions that allow you to use one source to warp another source. For example, .modulateRotate() is similar to .rotate(), but it allows you to apply different amounts of rotation to different parts of the visual source. See the function reference for more examples.\nMore blending and modulating # In addition to using multiple outputs to combine visuals, you can also combine multiple sources within the same function chain, without rendering them to separate outputs.\nThis allows you to use many sources, blend modes, and modulation, all from within the same chain of functions.\nTrick: use ctrl + shift + f from the web editor to auto-format your code\nModulating with the camera # We have now covered all of the basic types of functions within hydra: source, geometry, color, blending, and modulation! See what you can come up with by mixing these together.\nHave fun! # "},{"id":30,"href":"/docs/docs/learning/interactivity/","title":"interactivity","section":"learning","content":" interactivity # Here you\u0026rsquo;ll find different ways of getting external data into your Hydra patches to make it interactive or reactive.\nmouse # Using your mouse position as a value inside Hydra.\naudio # Getting values from your microphone\u0026rsquo;s audio.\nmidi # Use MIDI messages to change values or trigger stuff inside your sketches.\n"},{"id":31,"href":"/docs/docs/learning_tutorial/guides/contributing/","title":"Developing and contributing","section":"More Resources","content":" Developing and Contributing # In this guide, you will learn how to \u0026ldquo;compile\u0026rdquo; hydra, to test your own version, and to contribute to the original repository. This guide is for those who are familar with JavaScript to edit the code base. Knowledge of command line and front-end tools is preferred but we try to guide you step by step.\nUnderstanding the structure # Hydra consists of mainly 4 repositories:\nhydra hydra-synth hydra-server l10n hydra, or hydra-editor, is the webpage that comes with the editor. If you want to make changes in, e.g., the behavior of the editor, this is the right repository. We will look into detail in developing editor.\nhydra-synth is the \u0026ldquo;engine\u0026rdquo; that processes your hydra code on the editor and produces GLSL (shader) code. We explain in detail in developing synth.\nhydra-server is a backend program for signaling and storing the gallery. Note that you don\u0026rsquo;t need this for testing the editor. We explain in detail in developing backend server.\nl10n is a collection of locale files, i.e., translations for the editor interface. If you want to contribute translations, please refer to this doc.\nAll contributors # Thank you to everyone who contributed to the project, not only contributing the code, but including reporting bugs, organizing events, and making tutorials, etc! We would like to acknowledge everyone who contributes to make hydra better. Please submit your information here.\n"},{"id":32,"href":"/docs/docs/learning_tutorial/guides/contributing/server/","title":"developing backend server","section":"Developing and contributing","content":" Developing backend server # (stub)\n"},{"id":33,"href":"/docs/docs/learning_tutorial/guides/contributing/editor/","title":"developing editor","section":"Developing and contributing","content":" Developing editor # To run locally, you must have nodejs and npm installed. Install node and npm from: https://nodejs.org/en/.\nFirst, clone the repository\ngit clone git@github.com:hydra-synth/hydra.git enter the directory of the hydra source code:\ncd hydra Current main branch # The current main branch uses browserify to bundle the script. While new features should be implemented in dev branch, if there is a hot fix needed in the current main branch, please follow this guide.\nOnce you have node and npm installed, you can install yarn globally by running the following from the command line:\nnpm install --global yarn install dependencies:\nyarn install bundle JavaScript with browserify:\nyarn build run server\nyarn serve go to http://localhost:8000 in the browser. Congratulations! You built hydra-editor on your computer!\nWhere do these commands come from? # Yarn commands are defined in package.json.\nDevelopment # Make your new branch\ngit checkout -b my-awesome-feature Edit the code. If you want to see changes in real time, you can use the watch script. After running yarn serve, open another terminal and run\nyarn watch Then every time you save code, it will automatically re-bundle the code.\nServing on your own server # (stub)\nCommit, push and pull request # (stub)\ndev branch # New features should be implemented in dev branch. After entering the directory, checkout the branch\ngit checkout -b dev origin/dev install dependencies:\nnpm install run dev environment\nnpm run dev Since we use vite in dev branch, we don\u0026rsquo;t need to bundle the code during development (vite takes care of bundling and serving while you code). When you want to publish the code, build the bundle:\nnpm run build Connecting to server from dev/ local editor environment # This repo only contains hydra editor frontend. You can connect to a backend server (https://github.com/hydra-synth/hydra-server) for signaling and gallery functionality. To do this, set up hydra-server from above. Then create a .env file in the root of the hydra directory. Add the url of your server as a line in the .env file as:\nVITE_SERVER_URL=http://localhost:8000 (replace http://localhost:8000 with the url of your server)\n"},{"id":34,"href":"/docs/docs/learning_tutorial/guides/contributing/synth/","title":"developing hydra-synth","section":"Developing and contributing","content":" Developing synth # Clone the repository\ngit@github.com:hydra-synth/hydra-synth.git enter the folder\ncd hydra-synth install the dependencies\nnpm install build\nnpm run build The bundled code is in dist/hydra-synth.js.\nTrying on the browser # This repository does not come with the editor. However, you can use the simple example dist/index.html. To do so, install http-server\nnpm install --global http-server and serve dist folder\nhttp-server dist go to http://localhost:8000 in the browser. You can either edit the hydra code in index.html to try hydra functions, or open the developer console and type hydra code (e.g., osc().out()) and it will update the canvas. The former is useful for testing more complex examples including non-global mode, and the later is useful for quick testing.\nFor testing the integration with hydra-editor (of if you want to host your own hydra version on your server), please follow editor guide to host your own editor. Then, edit package.json in hydra (not hydra-synth) to use the local version of hydra-synth (assuming you have hydra and hydra-synth folders in the same folder)\n\u0026quot;hydra-synth\u0026quot;: \u0026quot;file:../hydra-synth\u0026quot;, Then in hydra, update the package\nnpm update hydra-synth Now the editor is using your version of hydra-synth.\n"},{"id":35,"href":"/docs/docs/learning_tutorial/guides/","title":"More Resources","section":"learning","content":" More Resources # Guides # Deeper dives into hydra topics written by members of the hydra community.\nJavascript for hydra users by geikha Generatively spawn patches by geikha Precise control of frames and timing by geikha Hydra Book: Textures by Naoto Hieda How to # Record hydra output Use hydra without showing the code Developing and Contributing # overview hydra-synth hydra-editor hydra-server "},{"id":36,"href":"/docs/docs/learning/guides/","title":"guides","section":"learning","content":" guides # Deeper dives into hydra topics written by members of the hydra community.\nGuides # Javascript for Hydra Users by Geikha Iteration \u0026amp; generative patches by Geikha Updating frames \u0026amp; precise timing by Geikha \u0026ldquo;Textures\u0026rdquo; from the Hydra Book by Naoto Hieda Audio-reactivity explained by Geikha Using clicks \u0026amp; keyboard presses in Hydra by Geikha How to\u0026hellip; # Embed Hydra on your webpage Record Hydra\u0026rsquo;s output Use Hydra without showing the code "},{"id":37,"href":"/docs/docs/learning/video-synth-basics/src/","title":"sources","section":"video synth basics","content":" sources # Sources are functions that generate video signals. These are the fundamental pieces of our visuals, we connect them to transforms and mix them with other functions in order to create our visuals. Using a musical analogy: sources are like instruments (guitars, oscillators, keyboards) and we connect them to transforms (effects) in order to create cool stuff.\nSome source functions # osc # A visual oscillator, goes from black to white smoothly. The frequency defines how many oscillations are made along the screen. The sync how fast they move. The offset offsets each color channel (Red, Green and Blue).\nosc( frequency = 60, sync = 0.1, offset )\nsolid # Outputs a solid color that covers the whole screen. You can set the value for each color channel (Red, Green, Blue and Alpha).\nsolid( r, g, b, a = 1 )\nnoise # Generates 2D slices of Perlin noise. You can set the both the scale and how fast the noise changes using the first two arguments.\nnoise( scale = 10, offset = 0.1 )\nPlease note that the noise generator outputs both positive and negative values. # voronoi # Generates Voronoi shapes. You can set the scale, the speed at which they change and their blending.\nvoronoi( scale = 5, speed = 0.3, blending = 0.3 )\nshape # Generates simple polygons, You can set how many sides they have, the size radius and how smooth the edges are.\nshape( sides = 3, radius = 0.3, smoothing = 0.01 )\ngradient # Outputs a simple gradient sequence. You can set the speed at which the blue channel oscillates.\ngradient( speed )\nA special src # src # Accepts a texture (framebuffer) and shows it on screen, such as external sources (s0, s1, s2, s3) or a Hydra output (o0, o1, o2, o3). This allows us to include external images in our patch or to connect patches with each other.\nsrc( tex )\nOutputting # Following the musical analogy from above, all instruments (sources), regardless of how many effects (transforms) we add need to be outputted to some speakers (output). The special Hydra function that allows us to output our visuals to a framebuffer is called out.\nout # out( output = o0 )\nSee the interactive function reference for a glossary of all the functions.\n"},{"id":38,"href":"/docs/docs/learning/video-synth-basics/outputs/","title":"outputs","section":"video synth basics","content":" outputs # By default, hydra contains four separate virtual outputs that can each render different visuals, and can be mixed with each other to create more complex visuals. The variables o0, o1, o2, and o3 correspond to the different outputs.\nThe out function # The special Hydra function that allows us to output our visuals is called out.\nout( output = o0 )\nThe src function # In the example above you can also see the src function, which allows use to access the video signals in framebuffers such as outputs or external sources. This is how take video from outputs and route them mixing them with each other.\nsrc( texture ) default available textures are: o0, o1, o2, o3, s0, s1, s2, s3\nUsing multiple outputs # Rendering all outputs at once # To see all four of the outputs at once, use the render() function. This will divide the screen into four, showing each output in a different section of the screen.\nUsing a different variable inside the .out() function renders the patch to a different output. For example, .out(o1) will render a function chain to the framebuffer o1.\nRendering an output on screen # By default, only output o0 is rendered to the screen, while the render() command divides the screen in four. Show a specific output on the screen by adding it inside of render(), for example render(o2) to show buffer o2.\nTrick: try to create different sketches and switch them in your live performance or even combine them.\n"},{"id":39,"href":"/docs/docs/learning/video-synth-basics/transforms/","title":"transforms","section":"video synth basics","content":" transforms # Transforms are the functions that we can call over sources using dots. They are \u0026ldquo;effects\u0026rdquo; that we can apply to visuals and chain together. There are different type of transforms, the most basic ones being color and geometry.\nColor transform Geometry transform Changes the content of pixels (its colors and their transparency) Changes the placement of pixels Some color transforms # Color transforms change the colors (the RGBA values) for all pixels in a texture.\ninvert # Inverts the color of any visual. The amount argument allows us to bypass the effect by inputting 0, or exaggerate the effect using numbers higher than 1.\ninvert( amount = 1 )\ncolor # Allows you to modify (multiply) the color channels of a visual. Using negative values will invert only that channel (it doesn\u0026rsquo;t output negative values).\ncolor( r = 1, g = 1, b = 1, a = 1 )\nbrightness # Changes the brightness of the image by some amount.\nbrightness( amount = 0.4 )\nluma # Applies a luma key. This means it will remove any parts of the image with a luma (brightness) lower than the threshold value.\nluma( threshold = 0.5, tolerance = 0.1 )\nhue # Rotates the hue of colors in a visual. Inputting 1 (or any integer) will have unnoticeable effects, since each unit represents a whole turn in the color wheel. For example 0.5 will output complementary colors.\nhue( hue = 0.4 )\nMuch more # Check the color section in the interactive function reference for a glossary of all the color functions.\nSome geometry transforms # Geometry transforms will affect how the texture is displayed on screen, allowing us to do geometric changes such as rotating, scaling, positioning, and much more. They don\u0026rsquo;t affect the colors of the visuals but rather where they appear.\nrotate # Rotates a texture by some amount of radians. Most people just eyeball rotations on Hydra, but you can be precise by using Math.PI. You can also set a speed for automatic rotation.\nrotate( angle = 10, speed )\nscale # With scale you can zoom in or out of your visuals by some amount. You can also scale only horizontally or vertically. Inputting 1 won\u0026rsquo;t do anything, inputting 0.5 will be half the size, 2 double the size, and so on. The offset arguments let you place the center of scaling other than the center of the screen, in case you need that.\nscale( amount = 1.5, xMult = 1, yMult = 1, offsetX = 0.5, offsetY = 0.5 )\nscroll # Let\u0026rsquo;s you move textures left and right, up or down.\nscroll( scrollX = 0.5, scrollY = 0.5, speedX, speedY )\nkaleid # Kaleidoscope effect with nSides repetition.\nkaleid( nSides = 4 )\nMuch more # Check the geometry section in the interactive function reference for a glossary of all the geometry functions.\n"},{"id":40,"href":"/docs/docs/learning/video-synth-basics/blending/","title":"blending","section":"video synth basics","content":" blending # Blend transforms allow you to combine the colors of two visual sources. There are many ways of operating with them. There are multiple blend modes in Hydra, similar to the blend modes you might find in raster graphics programs such as Photoshop or GNU-IMP. All blend functions take in a texture which can be a source, a patch or a framebuffer (such as o0, o1, s0, etc).\nSome blend transforms # blend # The simple blend functions mixes the colors from two sources to create a third source. You can also specify how much of the second texture you mix in. Inputting 0 will output the original texture unaffected, 0.5 (the default) mixes them 50%/50%, and 1 will only show the secondary texture. Going outside this range will create broken mixes, which can be interesting too.\nblend( texture, amount = 0.5 )\nadd # Adds the color channels of two images. You can multiply the second image with the amount argument, so you can add more or less from it. Using negative amounts will effectively subtract values instead of adding.\nadd( texture, amount = 1 )\nsub # Subtracts the color channels of one image to another.\nsub( texture, amount = 1 )\nmult # Multiplies the original image by the incoming one.\nmult( texture, amount = 1 )\ndiff # Shows the difference between two textures. In other words: abs(img1 - img2).\ndiff( texture )\nlayer # Places a texture over another one using its transparency values.\nlayer( texture )\nmask # Uses a texture as a mask for the visual. Works in the same way a mask works in Photoshop or other raster graphics software: bright parts will make the image opace, while dark parts will make it more transparent.\nmask( texture )\nReference # Remember you can check the interactive function reference for a quick glossary of all the functions.\n"},{"id":41,"href":"/docs/docs/learning/video-synth-basics/modulate/","title":"modulation","section":"video synth basics","content":" modulation # While blend functions combine the colors from two visual sources, modulate functions use the colors from one source to affect the geometry of the second source. This creates a sort of warping or distorting effect. An analogy in the real world would be looking through a texture glass window. modulate() does not change color or luminosity but distorts one visual source using another visual source. Note how modulation is to geometry what blending is to color.\nAll geometry transformations have corresponding modulate functions that allow you to use one source to warp another source. For example, .modulateRotate() is similar to .rotate(), but it allows you to apply different amounts of rotation to different parts of the visual source. See the function reference for more examples.\nSome modulation transforms # modulate # Related to scroll, it will warp the image moving it upwards and leftwards in modulator\u0026rsquo;s bright areas. You can also set the amount of warping. Negative values will have move towards the opposite direction.\nmodulate( texture, amount = 0.1 ) modulateRotate # Related to rotate, it will rotate the image more or less according to the modulator. You can set the amount of warping and a rotation offset.\nmodulateRotate( texture, multiple = 1, offset )\nmodulateScrollX # Related to scrollX, scrolls the image horizontally according to the modulator. You can set the amount of warping and an independent scrolling speed.\nmodulateScrollX( texture, scrollX = 0.5, speed )\nmodulateScrollY # Related to scrollY, scrolls the image vertically according to the modulator. You can set the amount of warping and an independent scrolling speed.\nmodulateScrollY( texture, scrollY = 0.5, speed )\nmodulateScale # Related to scale, zooms in (or out) of the image according to the modulator. You can set the amount of zooming and a scaling offset. Negative values will down to -1 will scale down.\nmodulateScale( texture, multiple = 1, offset = 1 )\nmodulateHue # Modulate hue is special. It will warp the image according to the relation between the channels of the modulator. To be precise, it will warp horizontally according to the difference between green and red, and vertically according to the difference between blue and green. This isn\u0026rsquo;t intuitive but it\u0026rsquo;s an easy way of creating complex motion using colorful modulators.\nmodulateHue( texture, amount = 1 )\nMuch more # Check the modulation section in the interactive function reference for a glossary of all the modulation functions.\nExamples using the camera # "},{"id":42,"href":"/docs/docs/learning/video-synth-basics/settings/","title":"settings \u0026 state","section":"video synth basics","content":" synth settings # Functions, variables, and settings that affect overall hydra behavior and rendering.\nGlobal output # render # Chooses which output to show. If you don\u0026rsquo;t specify one, it will show all 4 outputs.\nrender( texture = all )\nhush # Empties all outputs.\nhush()\nTime-related functions # time # Tells you the amount of time that has passed since the synth started working. Usually called inside arrow functions.\ntime\nspeed # Makes time run faster or slower inside Hydra.\nspeed = 1\nbpm # Changes the rate at which Hydra goes through lists.\nbpm = 30\nResolution # setResolution # Sets the working resolution for the synth.\nsetResolution( width, height )\n// make the canvas small (100 pixel x 100 pixel) setResolution(100,100) osc().out(o0) width # Gets the current working width.\nwidth\nheight # Gets the current working height.\nheight\nInteractivity # mouse # Gets the position of the mouse on the webpage.\nmouse = { x, y }\nSee the interactivity area for more information.\nTransform definition # setFunction # Allows you to declare your own GLSL function for usage within Hydra.\nsetFunction( options )\nSee the custom GLSL page for more information.\nFrame rendering # update # update is a function that runs every time a frame is rendered. A bit like p5\u0026rsquo;s draw, only that this one isn\u0026rsquo;t crutial at all. It can also take in an argument, generally called dt, which contains the amount of time that passed between the previous and current frame.\nupdate( dt )\n"},{"id":43,"href":"/docs/docs/learning/sequencing/arrays/","title":"arrays","section":"sequencing","content":" arrays # When you send an Array as an input, Hydra will automatically switch and jump from each element from the Array to the next one. When there are no more elements, it wraps all the way back to the beginning. Let\u0026rsquo;s see it in action:\nAs you can see, the fact that both these Arrays have a different amount of values doesn\u0026rsquo;t matter, Hydra will take values from each element of any Array for the same amount of time by default.\nThe Arrays can be passed in any way, you may have a variable that stores an Array and use its name within your sketches (not recommended in some scenarios, more info below), you may create a function that returns Arrays and use that to automatically generate discrete sequences of values:\nbpm # To change how rapidly Hydra switches from element to element of all Arrays, you can change the bpm variable (meaning beats per minute) to any value you desire:\nThe default value for bpm is 30.\nWhen livecoding visuals at the same time that music is playing, it can be useful to have a tapping metronome opened to keep track of the BPM being played and set this variable as such.\nfast # Hydra adds a couple of methods to all Arrays to be used inside Hydra. .fast will control the speed at which Hydra takes elements from the Array. It receives a Number as argument, by which the global speed will be multiplied. So calling .fast(1) on an Array is the same as nothing. Higher values will generate faster switching, while lower than 1 values will be slower.\n[].fast( speed = 1 )\noffset # Another one of the methods Hydra adds to Arrays, allows you to offset the timing at which Hydra will switch from one element of the Array to the next one. The method .offset takes a Number from 0 to 1.\n[].offset( offset = 0 )\nfit # Sometimes you have an Array whose values aren\u0026rsquo;t very useful when used as input for a some Hydra function. Hydra adds a .fit method to Arrays which takes a minimum and a maximum to which fit the values into:\n[].fit( min, max )\nsmooth # You can also interpolate between values instead of jumping from one to the other. That is, smoothly transition between values. For this you can use the .smooth method. It may take a Number argument (defaulted to 1) which controls the smoothness.\n[].smooth()\nTry smoothing some of the above examples and see what happens!\nease # The default interpolation used by Hydra on an Array that called .smooth is linear interpolation. You can select a different easing function as follows:\n[].ease( easingFunc = \u0026quot;linear\u0026quot; )\nEasing functions # The following are the available easing functions:\nlinear: no easing, no acceleration easeInQuad: accelerating from zero velocity easeOutQuad: decelerating to zero velocity easeInOutQuad: acceleration until halfway, then deceleration easeInCubic easeOutCubic easeInOutCubic easeInQuart easeOutQuart easeInOutQuart easeInQuint easeOutQuint easeInOutQuint sin: sinusoidal shape Notes # Arrays as variables or functions # Storing an Array in a variable can lead to some trouble as soon as you apply some of the just-mentioned functions to it. Since Arrays are Objects, each time you call your variable, you\u0026rsquo;ll be calling the same Object. If you apply some speed via .fast or smoothness via .smooth somewhere in your patch, and then use the same variable, all the following uses of the Array will also have these effects applied to them. For example\nArrays and textures # Note that the following will not work:\nsolid(1,.5,0) .diff([osc(),noise()]) .out() Hydra can\u0026rsquo;t handle Arrays of textures. You can work around it in some ways:\nUnfortunately, if you want to use many textures this solution doesn\u0026rsquo;t really apply.\nUsers of Hydra have come up with some experimental solutions which might come in handy in some scenarios, but they come with some drawbacks:\n// blending method, heavy GPU load. // every element from the array will be rendered even if not shown. // allows for blending between elements. select = function(arr,l=0){ const clamp = (num, min, max) =\u0026gt; Math.min(Math.max(num, min), max) const blending = (l,i)=\u0026gt; (clamp(l-(i-1),0,1)) const isFunction = (typeof l === \u0026#39;function\u0026#39;) return arr.reduce((prev,curr,i)=\u0026gt; prev.blend(curr, isFunction ? ()=\u0026gt;blending(l(),i) : blending(l,i)) ) } textures = [noise(), osc(), voronoi(), gradient()] select(textures,()=\u0026gt;Math.floor(mouse.x/innerWidth*4)) .out() // re-compiling method, heavy CPU load. // it reserves an output for the switching. // can\u0026#39;t blend between elements. // each time an element switches the shader must be recompiled osc(20) .rotate() .modulate(o3,.2) .out() textures = [noise(), osc(), voronoi(), shape()] index = 0 tex = textures[index] update = (dt)=\u0026gt; { if(time % (60 / bpm) * 1000 \u0026lt; dt){ index++; index %= textures.length; tex = textures[index] tex.out(o3) } } A small bug # Currently, sketches using arrays with smooth have a small bug for the first few seconds (or more, depending on your bpm). Hydra tries to interpolate between the first element of the array with the one before, the problem being that there\u0026rsquo;s no element before the first one, so it returns a NaN. This shouldn\u0026rsquo;t be much of a problem, but you can try to circumvent this setting the time yourself: hydraSynth.synth.time = 60/bpm*128 "},{"id":44,"href":"/docs/docs/learning/sequencing/arrow-functions/","title":"arrow functions","section":"sequencing","content":" arrow functions # ()=\u0026gt; time # You can use dynamic inputs in your sketches by passing functions as arguments. When Hydra takes a function as an argument, what it will do is evaluate it every time it renders a frame. The return of the function will be used as the value for that parameter during that frame render. So you can use a function to simply keep track of a value that you know will change over time, for example, mouse position (which we\u0026rsquo;ll see later).\nThe time variable seen there is a variable pre-declared by Hydra, that stores how much time passed since Hydra started in seconds.\nFunctions used in Hydra don\u0026rsquo;t need to be arrow functions, any no-argument function will do! Make sure your function is returning a Number to avoid errors.\ntime # When you use functions that can take numerical arguments, time will allow you to have their values evolve through\u0026hellip; time. If you multiply time by some value it\u0026rsquo;s as if time goes faster, while dividing while act as making time go slower. For example Math.sin(time*4) will go 4 times faster than Math.sin(time).\nThose users more familiar with mathematics might see this as:\ny(t) = t : ()=\u0026gt;time y(t) = A sin(f t + ph) : ()=\u0026gt;amplitude*Math.sin(freq*time + phase) We recommend getting familiar with some of the methods in the JS built-in Math object. Learn more about it here\nspeed # You can either slow down or fasten the rate at with time increases via changing the speed variable:\nspeed = 1 // default speed = 2 // twice as fast speed = .5 // half as fast speed = 0 // freezed "},{"id":45,"href":"/docs/docs/learning/interactivity/mouse/","title":"mouse","section":"interactivity","content":" mouse # You can have your visuals react to the position of your mouse (or finger, in touch devices). Hydra has an object called mouse which stores and keeps track of the position of your mouse on the webpage.\nImportant note # All of the examples using mouse position to move stuff on the canvas won\u0026rsquo;t work well here, since the canvas doesn\u0026rsquo;t occupy the full size of the screen. Take this into account when using mouse, that the positions are relative to the full webpage and not the canvas. This also means that as you scroll down this guide the y value will get higher and higher. Open the following examples in the editor pressing the rocket emoji.\nmouse.x \u0026amp; mouse.y # You can refer to the pixel position of your mouse by calling mouse.x and mouse.y, each one corresponding to the horizontal and vertical coordinates respectively. When we say \u0026lsquo;pixel position\u0026rsquo;, this means that the values you\u0026rsquo;ll find stored in both x and y are represented in pixels. So for mouse.x, this means the amount of pixels from the left edge of your window to the position of your mouse. For mouse.y, this means the amount of pixels between the top end of your screen and the position of your mouse.\nMany times it will be most useful to use values relative to the size of the screen. And also to have values that exist between ranges more reasonable to the hydra functions you\u0026rsquo;re using. For example [-0.5; 0.5] for scrollX and scrollY, [0; 2pi] for rotation, or [0; 1] for general purposes.\nGetting values from 0 to 1 # On Hydra, most values used are pretty small. So it will be way more useful to have the position of the mouse as values from 0 and 1:\nGetting values from 0 to 2pi # It can be useful to have values from 0 to (two times pi), since 2pi is a full rotatio in radians, equivalent to 360 degrees:\nFollow your mouse # On Hydra, things are placed between 0.5 and -0.5 (left to right, top to bottom). In order for anything to follow your mouse, you\u0026rsquo;ll need to get the position of your mouse between that range.\nGetting values from 0 to ±0.5 from the center # More # If you want to explore the mouse further, you can extend your usage of the mouse to using clicks. Or you can even use your keyboard as an interactive element! Learn more about this on the clicks \u0026amp; keys guide.\n"},{"id":46,"href":"/docs/docs/learning/interactivity/audio/","title":"audio","section":"interactivity","content":" audio # The current version of Hydra can use the default microphone as an input, it uses Meyda in order to analyze the sound and get values for audio reactivity. This works internally using the FFT algorithm.\nthe a object # The a object gives you access to all of the audio functionality. Please follow along on the Hydra editor:\na.show # Show the FFT bins near the canvas.\na.show() a.setBins # Set the number of FFT bins. A bin is a part of the audible spectrum Hydra will analyze on the mic input.\na.setBins(6) a.fft[] # You can access the value of the leftmost (lowest frequency) bin by calling the first element in the a.fft array. Using higher numbers will get you the higher frequency bins.\na.fft[0] Usage # These should be used inside arrow functions, this way Hydra will check their value each time a frame is rendered, making the audio reactivity happen.\nosc(10, 0, () =\u0026gt; a.fft[0]*4) .out() a.setCutoff # It is possible to calibrate the responsiveness by changing the minimum and maximum value detected. (Represented by blur lines over the fft). To set minimum value detected:\na.setCutoff(4) a.setScale # Setting the scale changes the range that is detected. The a.fft[] array will return a value between 0 and 1, where 0 represents the cutoff and 1 corresponds to the maximum.\na.setScale(2) a.setSmooth # You can set smoothing between audio level readings (values between 0 and 1). 0 corresponds to no smoothing (more jumpy, faster reaction time), while 1 means that the value will never change.\na.setSmooth(0.8) a.hide # To hide the FFT bins:\na.hide() Example # a.setBins(5) // amount of bins (bands) to separate the audio spectrum noise(2) .modulate(o0,()=\u0026gt;a.fft[1]*.5) // listening to the 2nd band .out() a.setSmooth(.8) // audio reactivity smoothness from 0 to 1, uses linear interpolation a.setScale(8) // loudness upper limit (maps to 0) a.setCutoff(0.1) // loudness from which to start listening to (maps to 0) a.show() // show what hydra\u0026#39;s listening to // a.hide() render(o0) "},{"id":47,"href":"/docs/docs/learning/interactivity/midi/","title":"midi","section":"interactivity","content":" midi # hydra-midi # hydra-midi is one of the most used extensions for Hydra. It allows you to easily incorporate MIDI devices into your patches. These can be MIDI interfaces, controllers, virtual cables, etc. It can use both notes and CC values. For more information visit the hydra-midi repository\nExamples # Start-up # await loadScript(\u0026#39;https://cdn.jsdelivr.net/npm/hydra-midi@latest/dist/index.js\u0026#39;) // Use midi messages from all channels of all inputs. await midi.start().show() // Use specific inputs or channels seaboard = midi.input(1).channel(\u0026#39;*\u0026#39;) faderfox = midi.input(2) Notes # // Get a 0 when the note C4 isn\u0026#39;t pressed, 1 when pressed osc(30,.01).invert(note(\u0026#39;C4\u0026#39;)).out() // Trigger an ADSR envelope each time the note C3 is played // and scale the value to a range between 20 and 50. osc(note(\u0026#39;C3\u0026#39;).adsr(300, 200, 1, 300).range(20, 50), 0, 0).out(o1) // Get a 2 when the note D3 isn\u0026#39;t pressed in the seaboard, 8 when pressed noise(seaboard.note(\u0026#39;D3\u0026#39;).range(2,8)).out(o2) // Get the latest velocity played for the note E3 voronoi().color(note(\u0026#39;E3\u0026#39;).velocity(),1,1).out(o3) CC # // Get the value from CC 45 ranged from 0 to 2PI osc().rotate(cc(45).range(0,Math.PI*2)).out(o0) Remember to visit the hydra-midi repository for more documentation.\nCustom scripts # You can also use your own custom scripts using Web MIDI.\nThe following is a generic script that doesn\u0026rsquo;t care what Midi Channel you\u0026rsquo;re broadcasting on and maps a normalized value 0.0-1.0 into an array named cc. This portion should be ran in the console \u0026amp; will register Web MIDI \u0026amp; map the incoming CC data to a set of parameters. For simplicity, these parameters are named to match the CC number. The CC values are normally in a range from 0-127, but we\u0026rsquo;ve also normalized them to be in a range of 0.0-1.0.\n// register WebMIDI navigator.requestMIDIAccess() .then(onMIDISuccess, onMIDIFailure); function onMIDISuccess(midiAccess) { console.log(midiAccess); var inputs = midiAccess.inputs; var outputs = midiAccess.outputs; for (var input of midiAccess.inputs.values()){ input.onmidimessage = getMIDIMessage; } } function onMIDIFailure() { console.log(\u0026#39;Could not access your MIDI devices.\u0026#39;); } //create an array to hold our cc values and init to a normalized value var cc=Array(128).fill(0.5) getMIDIMessage = function(midiMessage) { var arr = midiMessage.data var index = arr[1] //console.log(\u0026#39;Midi received on cc#\u0026#39; + index + \u0026#39; value:\u0026#39; + arr[2]) // uncomment to monitor incoming Midi var val = (arr[2]+1)/128.0 // normalize CC values to 0.0 - 1.0 cc[index]=val } // example midi mappings - Korg NanoKontrol2 CCs // color controls with first three knobs noise(4).color( ()=\u0026gt;cc[16], ()=\u0026gt;cc[17], ()=\u0026gt;cc[18] ).out() // rotate \u0026amp; scale with first two faders osc(10,0.2,0.5).rotate( ()=\u0026gt;(cc[0]*6.28)-3.14 ).scale( ()=\u0026gt;(cc[1]) ).out() "},{"id":48,"href":"/docs/docs/learning/extending-hydra/extensions/","title":"extensions","section":"extending","content":" extensions # The Hydra community has put together many hydra-synth extensions which you can load into your sketches. This can be done using the loadScript function. Some of them add more sources, transforms, others have more intricate functionalities. There\u0026rsquo;s also a repository of extensions which you can load easily inside the editor by pressing the puzzle piece icon. Here we present some of the most used extensions:\nhydra-midi # by Arnoson # hydra-midi is one of the most used extensions for Hydra. It allows you to easily incorporate MIDI devices into your patches. These can be MIDI interfaces, controllers, virtual cables, etc. It can use both notes and CC values. For more information visit the hydra-midi repository.\nawait loadScript(\u0026#39;https://cdn.jsdelivr.net/npm/hydra-midi@latest/dist/index.js\u0026#39;) await midi.start().show() osc(30,.01).invert(note(\u0026#39;C4\u0026#39;)).out() osc().rotate(cc(45).range(0,Math.PI*2)).out(o1) hyper-hydra # by Geikha # hyper-hydra is a pack of diverse \u0026ldquo;hyper-usable hydra extensions\u0026rdquo;. The functionalities are quite varied, here\u0026rsquo;s a list of the most important ones. Learn more about it in its repository.\nName Description hydra-arithmetics All the functions you need to make complex visual arithmetics. hydra-arrays Extends the functionality of arrays in Hydra, letting you operate between different arrays and generate new ones. hydra-blend Adds most blending modes you know from raster image softwares. Ideal for compositing. hydra-colorspaces Work with color in different colorspaces such as CMYK, HSV, YUV, etc. hydra-convolutions Adds many convolutions such as sharpen, blur, sobel and more, as well as functions for creating your own. hydra-gif Load GIFs inside Hydra! hydra-glsl Write GLSL code directly between patches hydra-outputs Change the properties of Hydra\u0026rsquo;s outputs\u0026rsquo; framebuffers such as interpolation. hydra-src Adds alternative src functions which take into account the source\u0026rsquo;s aspect ratio or absolute size. Also adds rotateRel to rotate without distortion. hydra-text Adds a simple text generator to Hydra! Extra shaders for Hydra # by Thomas Jourdan # Thomas\u0026rsquo; own extension pack is widely used since it adds many useful functions to Hydra. You can learn more about it on its repository.\nName Description Op-art patterns New source functions inspired by op-art patterns. Soft patterns New source function which generate patterns with smooth transitions. Color filters Additional filters for mixing or manipulating colors. Noise Adds more types of noise to Hydra, including static, multi-octave perlin noise, domain-warping noise, and more. Screen space filters Used only in the last stage of the filter pipeline, they add typical renderpass effects such as blurring and dithering. There is also the related hydra-convolutions extension for a different code approach. Basic periodic functions Adds more simple periodic patterns (oscillators), such as a triangle wave, a square wave and a sawtooth wave. "},{"id":49,"href":"/docs/docs/learning/extending-hydra/extending-hydra/","title":"other libraries","section":"extending","content":" other libraries # Hydra is written in JavaScript, and compatible with many other JavaScript libraries. The hydra web editor executes JavaScript directly in the browser, so it is possible to load many other libraries and scripts directly in the browser.\np5.js # p5.js is a JavaScript library for creative coding, with a focus on making coding accessible and inclusive for artists, designers, educators, beginners, and anyone else! p5.js is pre-loaded on the Hydra editor with a wrapper that makes it easier to use inside the website. The wrapper is a class called P5 (notice the upper-case P). A p5.js sketch can be used as a source within a hydra sketch, and vice versa.\np5 + hydra example # // Initialize a new p5 instance It is only necessary to call this once p5 = new P5() // {width: window.innerWidth, height:window.innerHeight, mode: \u0026#39;P2D\u0026#39;} // draw a rectangle at point 300, 100 p5.rect(300, 100, 100, 100) // Note that P5 runs in instance mode, so all functions need to start with the variable where P5 was initialized (in this case p5) // reference for P5: https://P5js.org/reference/ // explanation of instance mode: https://github.com/processing/P5.js/wiki/Global-and-instance-mode // When live coding, the \u0026#34;setup()\u0026#34; function of P5.js has basically no use; anything that you would have called in setup you can just call outside of any function. p5.clear() for(var i = 0; i \u0026lt; 100; i++){ p5.fill(i*10, i%30, 255) p5.rect(i*20, 200, 10,200) } // To live code animations, you can redefine the draw function of P5 as follows: // (a rectangle that follows the mouse) p5.draw = () =\u0026gt; { p5.fill(p5.mouseX/5, p5.mouseY/5, 255, 100) p5.rect(p5.mouseX, p5.mouseY, 30, 150) } // To use P5 as an input to hydra, simply use the canvas as a source: s0.init({src: p5.canvas}) // Then render the canvas src(s0).repeat().out() breakdown of p5.js functions in hydra # p1 = new P5() // first, load p5 in instance mode You can also specify some settings:\np1 = new P5({width: 512, height: 512, mode: \u0026#39;P2D\u0026#39;}) Now the p5 canvas is overlaying the Hydra canvas. You can hide it by running:\np1.hide() // p1.show() to revert And you may load it to a source to use p5\u0026rsquo;s canvas as one:\ns0.init({src: p1.canvas}) p5.setup() # When live coding, the setup() function of p5 has basically no use; anything that you would have called in setup() you can simply call outside of any function. For example:\np1.noStroke() p1.fill(255, 0, 100) p5.draw() # Now, to set a draw loop simply use all the functions and variables you are used to on global p5 from the variable you\u0026rsquo;re using:\np1.draw = () =\u0026gt; { p1.fill(p1.mouseX/5, p1.mouseY/5, 255, 100) p1.rect(p1.mouseX, p1.mouseY, 30, 30) } Livecoding # You can technically call any p5 function while livecoding. So you can draw anything onto screen on evaluation instead of using the draw loop.\np1.clear() for(let i = 0; i \u0026lt; 50; i++) p1.rect(20, 20, p1.width/50*i, p1.height/50*i) Using Hydra\u0026rsquo;s render loop # You can stop p5\u0026rsquo;s own looping and do your p5 actions inside Hydra\u0026rsquo;s render loop via the update function. This will synchronize p5\u0026rsquo;s and Hydra\u0026rsquo;s frame renders.\np1.noLoop(); p1.clear() p1.colorMode(p1.HSB) p1.stroke(0) p1.strokeWeight(1) src(o0) .scale(1.05) .blend(src(o0).brightness(-.02),.4) .modulateHue(o0,100) .layer(s0) .out() p1.draw = () =\u0026gt; { if(p1.random() \u0026lt; 0.01) p1.clear() p1.fill(time*100%200, 70, 100) p1.rect(p1.random()*p1.width, p1.abs(p1.sin(time*2))*p1.height, 50, 50) } update = (dt)=\u0026gt; { p1.redraw(); } You could also use shape drawing functions such as rect directly inside update, but you\u0026rsquo;ll need to take into account the coordinate system won\u0026rsquo;t be reset automatically if modified, like when using draw. So you\u0026rsquo;ll have to reset it manually by putting actions between push() and pop(). This would also stop the frameCount increment.\nNote on using different frame rates # There are many situations where you can save resources by using a very low frame rate on p5 and a high one on Hydra or vice-versa. For example, if you want to place random shapes on the p5 canvas every second, you can set p5\u0026rsquo;s frameRate to 1 and leave Hydra\u0026rsquo;s fps undefined.\nTO DO: add example of using hydra as texture in p5\nTHREE.js # Here is an example using Three.js from the web editor:\nawait loadScript(\u0026#34;https://threejs.org/build/three.js\u0026#34;) scene = new THREE.Scene() camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) renderer = new THREE.WebGLRenderer() renderer.setSize(width, height) geometry = new THREE.BoxGeometry() material = new THREE.MeshBasicMaterial({color: 0x00ff00}) cube = new THREE.Mesh(geometry, material); scene.add(cube) camera.position.z = 1.5 // \u0026#39;update\u0026#39; is a reserved function that will be run every time the main hydra rendering context is updated update = () =\u0026gt; { cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render( scene, camera ); } s0.init({ src: renderer.domElement }) src(s0).repeat().out() Tone.js # Here is an example loading the Tone.js library:\nawait loadScript(\u0026#34;https://unpkg.com/tone\u0026#34;) synth = new Tone.Synth().toDestination(); synth.triggerAttackRelease(\u0026#34;C4\u0026#34;, \u0026#34;8n\u0026#34;); Strudel # Using Strudel to sequence your visuals using patterns is done with the experimental hydra-strudel extension.\nawait loadScript(\u0026#34;https://cdn.jsdelivr.net/gh/atfornes/Hydra-strudel-extension@1/hydra-strudel.js\u0026#34;) await initHydraStrudel() // Pattern languages are used to produce sound, but also to express graphic elements: pattern = \u0026#34;3 \u0026lt;4 5 6 7\u0026gt;\u0026#34; // using [tidal mini notation](https://tidalcycles.org/docs/reference/mini_notation/) // We could use this pattern to produce triangles, then squares, then triangles, etc: shape(P(pattern)) .out(o0) // We can reuse the same pattern to produce sounds as in any Strudel patch. n(pattern) .scale(\u0026#34;C:major\u0026#34;) .play() // Controlling colors src(o0) .color( () =\u0026gt; P(pattern)() % 2, () =\u0026gt; P(pattern)() % 3, () =\u0026gt; P(pattern)() % 5) .out(o1) render(o1) Custom libraries # You can load any external scripts or hydra-synth extensions using the following syntax at the top of your sketch:\nawait loadScript(\u0026#34;https://www.somewebsite.com/url/to/hydra-script.js\u0026#34;) You can also suffer from CORS policy problems if the script/package you\u0026rsquo;re loading doesn\u0026rsquo;t come from a CDN. If you want to load from a GitHub or GitLab repo, you can use special CDNs like statically.io. Learn more about this here.\nBy Geikha, Olivia Jack\n"},{"id":50,"href":"/docs/docs/learning/extending-hydra/glsl/","title":"custom glsl","section":"extending","content":" custom glsl # Using custom GLSL functions # Hydra is built using GLSL (a language for generating a program, or shader, that runs directly on the graphics card using WebGl). Each javascript function in hydra corresponds directly to a snippet of shader code. There are four possible types in hydra: src, coord (geometry), combine (blend), combineCoord (modulate). Each string of functions is composited based on its type into a single string of fragment shader code.\nYou can see the glsl for each existing hydra function in glsl-functions.js of the hydra source code.\nYou can see the fragment shader code generated by a chain of functions in hydra, by replacing the .out() in a function chain with .glsl(), and then logging the results.\nFor example, console.log(osc().glsl()[0]) will show the fragment shader generates by osc() in the browser console.\nsetFunction # The hydra-synth API includes a function called setFunction which lets you dynamically add a function with custom GLSL and custom name, and use it elsewhere in the code.\nname is a String with the name for the function type is one of the available types of functions (\u0026lsquo;src\u0026rsquo;, \u0026lsquo;color\u0026rsquo;, \u0026lsquo;coord\u0026rsquo;, \u0026lsquo;combine\u0026rsquo;, \u0026lsquo;combineCoord\u0026rsquo;, explained below) inputs is an Array of objects each with it\u0026rsquo;s own name, type and default properties. These become the arguments of the generated GLSL function. glsl is a String with the glsl code. Example # For example, the following code:\nsetFunction({ name: \u0026#39;gradient2\u0026#39;, type: \u0026#39;src\u0026#39;, inputs: [ { type: \u0026#39;float\u0026#39;, name: \u0026#39;speed\u0026#39;, default: 0, } ], glsl: ` return vec4(sin(time*speed), _st, 1.0);` }) Will generate the following GLSL function:\nvec4 gradient2(vec2 _st, float speed){ return vec4(sin(time*speed), _st, 1.0); } That is then usable in Hydra via gradient2().out()\nTypes of GLSL functions and their arguments # The value in the \u0026rsquo;type\u0026rsquo; field lets the parser know which type of function will be returned as well as default arguments. Here\u0026rsquo;s the reference for the different types as used inside Hydra:\nconst types = { \u0026#39;src\u0026#39;: { returnType: \u0026#39;vec4\u0026#39;, args: [\u0026#39;vec2 _st\u0026#39;] }, \u0026#39;coord\u0026#39;: { // geometry returnType: \u0026#39;vec2\u0026#39;, args: [\u0026#39;vec2 _st\u0026#39;] }, \u0026#39;color\u0026#39;: { returnType: \u0026#39;vec4\u0026#39;, args: [\u0026#39;vec4 _c0\u0026#39;] }, \u0026#39;combine\u0026#39;: { // blending returnType: \u0026#39;vec4\u0026#39;, args: [\u0026#39;vec4 _c0\u0026#39;, \u0026#39;vec4 _c1\u0026#39;] }, \u0026#39;combineCoord\u0026#39;: { // modulation returnType: \u0026#39;vec2\u0026#39;, args: [\u0026#39;vec2 _st\u0026#39;, \u0026#39;vec4 _c0\u0026#39;] } } src # A function with a specified type of src is one that generates visuals by its own. Just like osc or noise. They all have a vec2 argument called _st for the coordinate. And you can add any custom inputs as shown above. You must return a vec4.\ncolor # A color function receives a vec4 called _c0 that represents the color being affected by the transform. As any function you may add any extra inputs. You must return another vec4.\ncoord # A coord function receives a vec2 called _st that represents the coordinate plane. You must return another vec2.\ncombine # The functions of type combine receive 2 vec4 arguments, _c0 and _c1. The first one represents the texture being affected and the latter represents the texture being blended into the former. For example, when you use osc().mult(noise()), inside the definition of the function, _c0 represents the osc() and _c1 represents the noise() colors. You can think combine functions as blending modes. And as custom function you may add extra inputs as needed. You must return a vec4.\ncombineCoord # combineCoord functions change the position of colors in the texture being affected given the colors of another texture. Think about the many modulate functions for example, since they are precisely this type. They receive a vec2 _st and a vec4 _c0. You must return a vec2.\nBuilt-in functions # The following functions are pre-defined for every Hydra generated shader, and in the same way that some built-in functions use them, you may too:\n_luminance # float _luminance(vec3 rgb){ const vec3 W = vec3(0.2125, 0.7154, 0.0721); return dot(rgb, W); } Returns the luminance of a given rgb color.\nHSV functions # _rgbToHsv # vec3 _rgbToHsv(vec3 c){ vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r)); float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); } Transforms a color from the rgb to the hsv colorspace.\n_hsvToRgb # vec3 _hsvToRgb(vec3 c){ vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); } Transforms a color from the hsv colorspace back to rgb.\nNote # As of now there is no way to define \u0026ldquo;global\u0026rdquo; functions such as these ones just mentioned. But expect it soon!\nExample # Chroma Key # This example modifies color to replace green background with transparency (i.e., chroma keying). The GLSL code is ported from Inigo Quilez\u0026rsquo;s example.\nPolar coordinates # This example loads a coord function that warps a visual by interpreting its coordinates as polar.\nGLSL Injection # Since Hydra runs GLSL on the background, and everything you input into the parameters of the different functions ends up written on GLSL (be it literally or as a uniform), you can sort of hack Hydra (and totally break it) by sending strings of GLSL expressions as arguments:\nThe reason you can \u0026ldquo;totally break Hydra\u0026rdquo; here is that Hydra works with a modular flow. In order for it to work, when you do coordinate transforms on interconnected textures, these transforms must apply to all coordinate references in the shader. If you inject values of the st coordinates in your arguments, Hydra has no way of transforming them, therefore breaking the modularity.\nExtensions # Extra shaders # There are some Hydra extensions that load many custom glsl functions, such as:\nextra-shaders-for-hydra hydra-blending-modes Extra Functionality # The hydra-glsl extension allows you to write GLSL directly in your patches. For example:\nglsl(\u0026#39;vec4(sin(((_st.x*54.)+time*2.)*vec3(0.1,0.102,0.101)),1.0)\u0026#39;) .diff(o0) .glslColor(\u0026#39;vec4(c0.brg,1.)\u0026#39;) .glslCoord(\u0026#39;xy*=(1.0/vec2(i0, i0)); return xy\u0026#39;,.25) .glslCombine(\u0026#39;c0-c1\u0026#39;,o1) .glslCombineCoord(\u0026#39;uv+(vec2(c0.r,c0.b)*0.1)\u0026#39;,o1) .out() by Geikha\n"},{"id":51,"href":"/docs/docs/learning/extending-hydra/contributing/","title":"developing \u0026 contributing","section":"extending","content":" Developing and Contributing # In this guide, you will learn how to \u0026ldquo;compile\u0026rdquo; hydra, to test your own version, and to contribute to the original repository. This guide is for those who are familar with JavaScript to edit the code base. Knowledge of command line and front-end tools is preferred but we try to guide you step by step.\nUnderstanding the structure # Hydra consists of mainly 4 repositories:\nhydra hydra-synth hydra-server l10n hydra, or hydra-editor, is the webpage that comes with the editor. If you want to make changes in, e.g., the behavior of the editor, this is the right repository. See more about developing the editor.\nhydra-synth is the \u0026ldquo;engine\u0026rdquo; that processes your hydra code on the editor and produces GLSL (shader) code. We explain in detail in developing synth.\nhydra-server is a backend program for signaling and storing the gallery. Note that you don\u0026rsquo;t need this for testing the editor. We explain in detail in developing backend server.\nl10n is a collection of locale files, i.e., translations for the editor interface. If you want to contribute translations, please refer to this doc.\nAll contributors # Thank you to everyone who contributed to the project, not only contributing the code, but including reporting bugs, organizing events, and making tutorials, etc! We would like to acknowledge everyone who contributes to make hydra better. Please submit your information here.\n"},{"id":52,"href":"/docs/docs/learning/guides/javascript/","title":"JavaScript for Hydra users","section":"guides","content":" JavaScript for Hydra users # by Geikha\nThis guide is made for users who are new to JavaScript or coding in general and would like to dive into these topics. You don\u0026rsquo;t need to fully understand what\u0026rsquo;s here to use Hydra. If you\u0026rsquo;re just starting with Hydra and you have no coding experience, we recommend you experiment with Hydra a bit before reading this.\nComments # // This is a one line comment Most programming languages have implemented in them a feature commonly referred as comments. These are ways to write annotations into your code without having the machine interpret them as code. JavaScript, the scripting language that Hydra works on, has implemented comments in the same tradition as many other languages such as Java or C. You use // for single line comments, and you can use /* ... */ for multi-line comments.\n/* An example of a multi line commentary: This sketch shows an oscillator: */ osc().out() You can also write comments at the end of lines of code too, which is very useful while annotating what\u0026rsquo;s going on with your visuals sometimes:\nnoise(2,.5) .diff(src(o0).rotate(Math.PI/4)) // rotating by 45° .thresh(.5) .color(1,.1,.3) // pink color .out() You will surely find useful sometimes to \u0026ldquo;comment in and out\u0026rdquo; some lines of code to see how it affects the visuals, or simply to understand what each line of code does. By adding a // at the start of a line you can comment it out and see how some sketch would look like without a given transform without having to delete the original line.\nnoise(2,.5) .diff(src(o0).rotate(Math.PI/4)) // rotating by 45° //.thresh(.5) .color(1,.1,.3) // pink color .out() Variables # Variables are spaces of memory in your computer that you reserve to store some value. Each variable you use will have a unique symbolic name. This definition may sound complicated, but you\u0026rsquo;ll see it\u0026rsquo;s really as intuitive as it can be. You may remember variables from mathematics being letters that represent some sort of number. This is precisely the same, you just choose some name and assign some number (or other type of information) to it.\nIn the previous example, freq is the name of the variable and 50 is its value.\nVariable names can\u0026rsquo;t start with numbers, they start with letters and it\u0026rsquo;s conventional in JavaScript to start with a lowercase. When the name of your variable is more than one word, it\u0026rsquo;s also conventional to write them as such:\nHowever this is just a convention, you may find other ways of naming your variables more useful. You may even like to use only one letter variables (such as x, y, etc), it\u0026rsquo;s faster to code but harder for others to understand. Find your own balance and style.\nGlobal variables # When you declare a variable in Hydra, it declares it for you on the global scope. You can imagine a scope as a piece of code that works on its own and has its own variables. However, the global scope is basically a bunch of variables and functions that can be accessed from anywhere (functions such as osc() are declared in the global scope so that you can use them by just calling them, no matter where, for example). We can make it explicit that we want something on the global scope. In JavaScript, since it\u0026rsquo;s made to run on a browser, we do this by declaring variables on the window object (what is an object, you can find out below), which represents the browser\u0026rsquo;s window.\nwindow.globalVariable = 21.4 osc(globalVariable).out() However, you can drop the window. part since the default behavior is the same:\nglobalVariable = 21.4 osc(globalVariable).out() If you see JavaScript code elsewhere you\u0026rsquo;ll surely see the keywords let or const. These define variables on their scope. So avoid them if you want to declare variables that can be freely used while livecoding.\nlet scopedVariable = 21.4 // this will only work if evaluated on the same block osc(scopedVariable).out() This knowledge will come in handy if you start coding functions for example, since each function has its own scope, and if you want to declare something on the global scope, you\u0026rsquo;ll have to be explicit about it.\nArrays # Arrays are basically lists of values. Instead of declaring 100 variables to represent different values of the same concept you can just use a list of values. The key thing is these values are related, they will serve the same purpose somewhere in our code. If they are not related, using a list isn\u0026rsquo;t really useful, we\u0026rsquo;ll be just confusing ourselves thinking about where in the list did we put this or that other value. Here\u0026rsquo;s an example of an Array:\nThe example above isn\u0026rsquo;t that useful in a Hydra context, but we hope it illustrates the basics of how an Array is created and used. Arrays in JavaScript (and in most programming languages) start counting their elements from 0 and not from 1. So if you want the first element of the rots Array, you need to call array[0] instead of array[1]! Same goes for every element. If you want the third element call array[2], and so on. Remember that nth element = array[n-1]\nArrays as sequences # Arrays in Hydra can be used as inputs. Hydra takes the list of values and makes a sequence out of them:\nYou can learn more about dynamic inputs here.\nFunctions # A function is similar to a variable in the sense that you\u0026rsquo;re going to give it its own name and call it multiple times later. The difference being that functions do not store values, they store pieces of code that -usually- return some value. You can see them as little boxes where you put something in and they spit something out. Functions will help you not to repeat your code multiple times, sometimes you\u0026rsquo;ll see you can write a function that spits out what you need instead of rewriting it many times.\nDefining functions # There are multiple ways to define functions in JavaScript, here\u0026rsquo;s an example of a function named sum that takes two numbers called a and b and returns (spits out) the sum of both numbers:\nfunction sum(a,b){ return a+b; } sum = function(a,b){ return a+b; } sum = (a,b) =\u0026gt; a+b We\u0026rsquo;ll be sticking with the last form of defining functions, usually called \u0026lsquo;arrow function\u0026rsquo;. It is worth noting the first form it\u0026rsquo;s a bit like using let and const for variables, they work on their own scope.\nLocal variables in functions # Talking about scope, you may want to define variables inside your functions, which are local to the functions and aren\u0026rsquo;t variables that should be used globally. Now the let keyword becomes useful.\nsum = function(a,b){ let result = a+b; return result; } sum = (a,b) =\u0026gt; a+b Functions that return a texture # Now you may be thinking \u0026ldquo;Wait, shouldn\u0026rsquo;t this simply be a variable that stores that texture? If there\u0026rsquo;s no input what\u0026rsquo;s the use of having a function here?\u0026rdquo;. And in a way you would totally be right. Except for the fact that if you use a variable to store that shape, you\u0026rsquo;ll be always referring to the exact same object that represents that shape. If you use a variable circle and apply some transforms to it somewhere in your patch, and try to use circle again later, all the transforms that you applied will be there! Because you applied those to that object precisely. Also, even if you don\u0026rsquo;t apply any transforms, JavaScript can be very messy when referencing the same object multiple times in some situations. So, if you use a function, each time you call it a new object representing that texture will be created. Another reason we would use a function in this example is that if we want to add some input to this function, well, it\u0026rsquo;s already a function so we can do it.\nLet\u0026rsquo;s see how we could make the circle function more useful by adding parameters:\nNow, each time we call the circle function we can specify a size and blur. We can also omit the blur and the function will use the default value specified next to it. We also changed the scaling to an arrow function, which you may find surprising if you haven\u0026rsquo;t seen it before. When you use a function as an argument, Hydra will evaluate that function every time it renders a frame and use the return of that function in the rendering of that frame. In other words, functions can be used as dynamic inputs.\nUsing declared functions as inputs # As we just mentioned, we can use arrow functions inside the arguments of a given source or transform for it to react in real time. If you have many arguments using the same arrow function, you may want to declare it and reuse its name:\nCalling declared functions from other functions # Sometimes you want to reuse a function but have something change about it. For example, maybe we want to make the scaling negative for the feedback in the last example. But calling -scaling doesn\u0026rsquo;t make sense, at least to JavaScript, since the negative of a function doesn\u0026rsquo;t exist. But the negative of its return does:\nNote on functions with parameters # You\u0026rsquo;ll also come across this if your function has parameters. For example:\nscaling = (multiplier)=\u0026gt; (.9+(Math.sin(time*2)/3))*multiplier Doing .scale(scaling) doesn\u0026rsquo;t make sense anymore, since you aren\u0026rsquo;t giving it its necessary input. And if you try to do .scale(scaling(-1)), Hydra will evaluate the function once and use its return as the input to scale, instead of using a function which is what we want for the visual to react to the changes in time. The solution is, again, a function that calls your function, such as .scale(()=\u0026gt;scaling(-1)). If for some reason you hate arrow functions, you could also try binding it doing .scale(scaling.bind(0,1)).\nHigher-order functions # Higher order functions just means functions that take other functions as arguments. These are useful when you want to make u new functions which take behavior from other functions. As an example, let\u0026rsquo;s visualize applying a sine function (with some tweaks) to itself:\nThat new ...args thing simply takes all the arguments sent to a function, we use it so we can call whatever function sent with as many arguments as it needs. Take into account twice(myFunc,time) is the same as myFunc(myFunc(time)), and you may prefer to write the latter in many occasions. But you can also send an arrow function to twice, which could save you declaring a functions you may only want to use once, or writing the same declaration twice.\nObjects # You can imagine an object as a special variable, which instead of containing a value, it contains other variables and functions. The former are usually called properties of an object and the latter are methods of an object. For example, if you ever use Hydra on instance mode, what you\u0026rsquo;ll come across is Hydra as a special object containing all the functions you know and love, instead of having them on the global scope.\nLet\u0026rsquo;s see an example of how to declare and use an object with some properties:\nAnd now let\u0026rsquo;s add a method:\nThere\u0026rsquo;s a new keyword that we hadn\u0026rsquo;t seen before here: this. The this keyword is used in methods (functions of an object) to refer to the object from which the method is called.\nObjects can also be conceptualized as dictionaries, with keys and values. The keys would be the names of the properties (and methods) of the object and the values is what they store:\nnumbers = { pi: 3.14159265359, e: 2.71828182846, golden: 1.61803398875 } numbers[\u0026#39;pi\u0026#39;] // another way we can call keys from an object Useful properties in the window object # The window object has lots of information about the environment that our visuals run on. You\u0026rsquo;ll see lots of Hydra sketches that make use of them, more commonly for example, the innerWidth and innerHeight properties. These properties store the respective width and height that the webpage occupies on your screen.\nFor example, we can calculate the ratio between height and width to have perfect squares on our sketches:\n// this example will only work on the editor or atom-hydra screenRatio = innerHeight/innerWidth shape(4,.4).scale(1,screenRatio) .out() There\u0026rsquo;s also the less used screenX and screenY which will tell you the position of the window relative to the full screen. Try to move your browser\u0026rsquo;s window with the following example:\nThe Math Object # You have surely seen many examples in Hydra and in these tutorials that make use of mathematical functions such as the sine wave. You may have also noticed that each time one of them is used, they\u0026rsquo;re written as Math.somefunction(). The reason for this is that all these very useful functions are taken from a special object called Math that is present in practically every JavaScript implementation. You can see the full list of functions and variables in the Math object clicking here.\nMath.PI # One of the most useful predefined variables that the Math API has is the value of pi (well, an approximation considering that pi has infinite decimals). Many Hydra functions take radians as arguments which you may know are usually represented using multiples of pi. For example, if you want to rotate a texture exactly half a pi (90 degrees), you can do it as such:\nby geikha\n"},{"id":53,"href":"/docs/docs/learning/guides/automatic-patches/","title":"Iteration \u0026 generative patches","section":"guides","content":" Iteration \u0026amp; generative patches # by Geikha\nFor this tutorial we\u0026rsquo;ll be assuming you\u0026rsquo;ve already learned by your own means what iteration and conditionals are in a programming context. Iteration : automatically generate patches # As you may know from regular programming, or other creative coding environments such as p5, iteration helps us repeat some operation(s) many times to achieve a specific goal. Maybe you would like to layer many similar objects but with slightly different values, and you want so many of them that writing each one manually isn\u0026rsquo;t desirable. Maybe you want to have some form of very specific feedbacks, etc. Let\u0026rsquo;s jump straight into some examples.\nfor loops # For loops that generate patches can be used inside or outside functions, but we will be sticking with the latter for convenience.\nThe typical structure of a patch-generating for loop is as follows:\nsomeFunction = (iterations) =\u0026gt; { accumulator = osc(); // first part of the patch, a source for(i=1; i\u0026lt;iterations; i++){ // i is also called a \u0026#34;counter` accumulator.someTransform(i); } return accumulator; } someFunction(5).out() Of course this is just a useful example, and your code may end up looking very different depending on what crazy ideas you want to try. But let\u0026rsquo;s use this as a starting point. See how the use of a function allows us to reuse this iterative process with different parameters such as the amount of iterations. Also note how we start the counter variable i on the value 1 instead of the typical 0. Since 0 will usually null an effect, the result will be equal to the first value assigned our accumulator, so we can skip the 0 iteration altogether. For those not familiar with the abbreviation i++, this basically means i+=1, which means i = i+1.\nExample: rotating # Here we want to see how it would look like if we grab an oscillator of a given freq frequency, and calculate the diff between other rotated oscillators of the same frequency. To achieve that, we define our accumulator nest with the initial value of osc(freq,.02). Then, we define a step which will be how many radians the oscillator will rotate. We calculate this as a division of 2pi (a full 360° turn) by some div number. Then we iterate over nest, applying the diff and the effect respectively, and adding a step to our counter r each iteration.\nExample: very specific feedback # Example: layering varying circles # Try adding or changing the transforms that happen to every nextCircle and see how drastically yet easily they can change the visuals. Specially using transforms like repeatX. Still, always keep in mind while using iteration, that the more effects and iterations you add, the heavier the sketch will be to process.\n.forEach, .map and .reduce # Those familiar with more array focused programming languages such as Python or Haskell, or more functional structures even inside JavaScript, may be used to iterating using the forEach, map and/or reduce structures. Where given an Array, we use each value to alter something or to reduce the entire Array into a desired result. Practically anything done with these functions can be done using for loops, so if you are new to these or you just don\u0026rsquo;t like how they look, then there really is no need for you to learn these, even if you\u0026rsquo;re super interested in iteration.\n.forEach # Structures using .forEach are quite useful for those who\u0026rsquo;d like to generate patches from predefined data. Here\u0026rsquo;s an example using the ASCII values of a given string:\nTry changing the text, and remember not to use very long strings given they will be quite heavy to process.\n.reduce # Using .reduce is quite useful when you have an array of textures. Here\u0026rsquo;s a simple example:\n.map # Haters of state (non-political) will prefer .map any day over .forEach. Looking at the example for .forEach, we see were creating a texture and adding it to an accumulator for each element in the Array. We can separate the texture generating part of the code and the blending part using .map to get an array of textures and .reduce to blend them:\nConditionals # Conditionals aren\u0026rsquo;t very useful on their own here, given all code execution on Hydra happens arbitrarily and manually via the interaction of the user. The only case you would want to use an if statement by its own while livecoding Hydra is that where you\u0026rsquo;d like some variable to change given some condition and only at the time of each code evaluation. But even still, you\u0026rsquo;ll see that putting any conditionals inside functions will be the most useful approach because of code reusability and readability. Let\u0026rsquo;s get to it.\nConditionals in functions # We know from previous tutorials we can make our own functions to be used as arguments of Hydra sources and transforms, and how Hydra evaluates these functions each frame. Here\u0026rsquo;s an example where we use conditionals to have a hue change happen only during 3 seconds out of every 10 seconds:\nAnother common use of conditionals in programming is to avoid errors or undesired behaviors. Here\u0026rsquo;s a simple example where we wrap the square root function from the Math API into our own sqrt function which turns any negative input into positive:\nThe ternary operator # Before we go forward and use both iteration and conditionals, we\u0026rsquo;d like to show you the ternary operator. This operator can simplify many conditional operations. The syntax is the following:\nx = condition ? valueIfTrue : valueIfFalse; // which is the same as if(condition) x = valueIfTrue else x = valueIfFalse Now we can simplify the hue change example into:\nosc(20,.1,2.6) .modulate(osc(20).rotate(Math.PI/2),.3) .hue(()=\u0026gt; time%10\u0026lt;3 ? time/2 : 0) .out() Conditionals inside iterations # Let\u0026rsquo;s go back to a previous example, the nest, where we wanted to do many diff using the same oscillator many times with different angles of rotation. Here\u0026rsquo;s a new version where we invert the colors of the first half of oscillators, and we apply colorama to the oscillator in every other iteration.\nThe first change you\u0026rsquo;ll notice is that now we\u0026rsquo;re calculating the angle of rotation r inside the iteration, and for that we now use a regular counter such as i. We can get the exact same angle of rotation as before via multiplying the counter by the step. We do this specifically because if we want to have something happen every other condition, we\u0026rsquo;ll need to know if the number of iteration we\u0026rsquo;re in is even or not. This is what happens at if(i%2==0). However we still make use of r inside of the first conditional, if(r\u0026lt;Math.PI). This will result in about half of the oscillators to be inverted, given Math.PI is half a turn.\n"},{"id":54,"href":"/docs/docs/learning/guides/frames-and-timing/","title":"Updating frames \u0026 precise timing","section":"guides","content":" Updating frames \u0026amp; precise timing # by Geikha\nUsing the update function # There\u0026rsquo;s a function in the Hydra API called update. This function runs at the beginning of every frame render right before the values for time and a.fft are calculated. If you are familiar with Processing or p5, you can think of update as Hydra\u0026rsquo;s equivalent to the draw function. Using update can be very useful for creating generative visuals (generative in the sense of controlling visual elements with values that evolve through time either randomly or following certain rules). It can also be used to have a finer and/or connected control over parameters when compared to using simple arrow functions as arguments. It is also worth noting that the function receives a dt argument, which contains the delta time elapsed between the rendering of the previous frame and the current one. You may or may not want to use this to control your visuals (most of the examples don\u0026rsquo;t use it, actually).\nExamples # Using update and time to have complex control of parameters through time # The structure time % every \u0026lt; duration is super useful to make stuff happen every certain amount of seconds, for a given duration (also in seconds). time % wavelength / wavelength can be interpreted as a sawtooth wave with a given wavelength. This would generate an ascending sawtooth going from 0 to 1 in the amount of time specified by whe wavelength. For a descending one you can write something like 1-(time % wavelength / wavelength). If you want values from 0 to wavelength just remove the division.\nAdding a frame counter to make frame-specific actions # Having something appear for only one frame can be super useful in many feedback-based sketches:\nRandomly evolving values through time (Random walker) # update vs Arrow functions # Every function that you use as an argument is evaluated right before the current frame is about to be rendered. Which is the same thing that happens with the update function! This means, unless we use dt, everything we can do on update we can technically do on argument functions. It\u0026rsquo;s up for us to decide when one\u0026rsquo;s better than the other. If we are controlling many interconnected variables and procedures, most probably, an arrow function or a named function won\u0026rsquo;t be that nice to use. It\u0026rsquo;ll be confusing as to why a function which is supposed to represent a simple dynamic argument is doing so much stuff inside of itself. Maybe we could separate the different behaviors into many arrow functions. But if these functions were to feed from each other, this will yet again get confusing quite rapidly. Even then, there are many scenarios where an arrow function can do the same work as the update function with less code. For example, here\u0026rsquo;s a patch where a circle chases your mouse:\n"},{"id":55,"href":"/docs/docs/learning/guides/textures/","title":"Textures [Hydra Book]","section":"guides","content":" Textures # by Naoto Hieda\nIn this chapter of the Hydra Book, we discuss textures or patterns, separately from colors or movements. Most of the snippets have low saturation in order to separate textures from other effects.\nOscillator # osc(freq,sync,offset) is one of the basic sources to create a texture. The first argument determines the frequency (i.e., how packed the stripes are), the second for the sync (i.e., the scroll speed), and the third for the offset, which adds color to the pattern. One cycle of an oscillator in the screen space can be achieved by osc(Math.PI * 2); thus the following example shows 10 cycles:\nFor simplicity, natural numbers are often used as freq or the first argument (e.g., osc(40,0)). The sync parameter is multiplied with time and freq; thus even if sync is unchanged, the larger the frequency, the faster the scroll speed (discussed in motions). offset cycles from 0 to PI*2, which shifts the color.\nBy adding thresh() or posterize(), the oscillator pattern becomes clear stripes. thresh(threshold) literally thresholds the grayscale value; if the pixel\u0026rsquo;s grayscale is brighter than threshold, returns white and else returns black (alpha is preserved). posterize(bins,gamma) thresholds with multiple steps, similar to histogram. pixelate() achieves a similar effect; however, the offset between the bumps of the oscillator and the pixelation bins can create artifacts.\n(render() displays four buffers; o0 on top left, o1 on bottom left, o2 on top right and o3 on bottom right)\nkaleid() with a large number creates circles,\n99 is a magic number; to save character counts (which is essential for live coding), 99 is big enough and only takes 2 characters. However, depending on the effect you want to create, you might need to set a higher number, such as 999, or 1e4.\nYou might have noticed that this sketch is stretched if the window is not square. scale(amount,x,y) can correct the scaling; it scales amount*x to x-axis and amount*y to y-axis. Therefore, scale(1,1,16/9) fits the sketch to 16:9 window, and in general,\nscale(1,1,()=\u0026gt;window.innerWidth/window.innerHeight) adapts the sketch to any size of the window. Notice ()=\u0026gt;, which is an arrow function. If a value is passed to a hydra function (e.g., scale(1,1,window.innerWidth/window.innerHeight)), it will be evaluated only once when ctrl+enter or ctrl+shift+enter is pressed. However, an arrow function is evaluated every frame; thus, it becomes responsive to the window size change. In the rest of the book, a square window is assumed for simplicity. Note that width and height global variables are set when the hydra canvas is initialized, and they will not change according to window resizing.\nkaleid with a small number creates a geometric shape (in the example, an oscillator is combined with kaleid and thresh).\nNoise # noise() is another basic function as a source. A texture is generated based on a variant of Perlin Noise.\nWe will look more into detail in the modulator and arithmetic sections.\nVoronoi # voronoi() is a source to generate a Voronoi diagram.\nShapes # shape(sides,radius,smoothing) generates a polygon with a number of sides set by sides. Nevertheless, it is more than just a polygon - radius changes the size of the shape, and most importantly, smoothing sets gradient of the shape; 1 for fuzzy borders and close to 0 for sharp edges (however, setting to 0 does not work in recent versions). For example, shape(2) is a thick line, which can be scaled to make a thin line.\nor simply,\nBy repeating shape(4) and overlapping them, it gives a grid-like pattern. For convenience, a parameter and a function are stored in JavaScript variables.\nSimilar to kaleid(), shape() with a large number of sides creates a circle. By tweaking the example above, it generates a Polka dot pattern.\nor almost equivalent with (the center of the image will be horizontally shifted)\nThis tiling technique can be used to create a RGB pixel filter. In this example, func is decomposed into R, G, and B channels and overlaid on top of each other.\nScaling # Scaling and difference can also create a periodic texture.\nThis technique can also be applied to a complex texture.\nThe effect can be enhanced by thresh and setting the third argument of voronoi to 0, to have sharp edges. However, a naive implementation will end up in a complete noise (notice that thresh(threshold, tolerance)\u0026rsquo;s tolerance has to be always bigger than 0).\nTo have a desired effect, apply a square mask (before trying the next example, apply solid().out(o0) to clear the buffer).\nThis example can be used together with rotation.\nOr, instead of scale, scrolling functions (scrollX and scrollY) can be used with a feedback loop.\n"},{"id":56,"href":"/docs/docs/learning/guides/audio/","title":"Audio-reactivity explained","section":"guides","content":" Audio-reactivity explained # by Geikha\nReacting to audio # In order to achieve audio reactivity, Hydra makes use of a JavaScript library called Meyda and has a pre-defined object called a to access many of its features. Audio reactivity in Hydra is mainly achieved using an algorithm called Fast Fourier transform. You definitely don\u0026rsquo;t need to know what it is or how it achieves what it does to use it, but you need to understand the following:\nThe audio spectrum # Sound travels through air as a wave, that\u0026rsquo;s fairly common knowledge. This basically means that sound is nothing more than air pressure going up and down through time very fast in weird ways. But we don\u0026rsquo;t experience sound simply as something that goes on and off like a light flickering, many of the sounds we are used to have some sort of frequency or repetition that we interpret as higher or lower pitch. When we listen to a song we can easily differentiate the bass guitar from the singer even if both are playing at the same time. If there are two vocals being sung at the same time, even if by the same person, we can differentiate them because of how high or low they are (also because of timbre, but that doesn\u0026rsquo;t matter at all right now). When we talk about the audio spectrum, we are talking about the many frequencies a sound can cover and we humans can hear. What a fast fourier transform does is basically hear some ongoing sound and interpret how present the sound is on different parts of this spectrum. For example, if we separate the audio spectrum in 3 equal parts and play a drum-kit, the bass drum will have more presence on the lower side of the spectrum, while a hi-hat will surely have most of its presence on the higher third part of the spectrum.\na.show() \u0026amp; a.hide() # We can see what Hydra hears by calling the function a.show(). This will show a small graphic on the lower right corner of the screen. If we want to hide it we can call a.hide()\na.setBins() \u0026amp; a.fft # We can decide into how many parts we want to separate the audio spectrum using the function a.setBins(). As you might\u0026rsquo;ve already guessed, a bin is just a part of the audio spectrum. Try now to use very high values since more bins means more processing and you can go overkill easily. But also, you\u0026rsquo;ll see there usually isn\u0026rsquo;t much need to separate the spectrum into that many parts. To read the current value of a bin we use an Array (a list of variables per se) called a.fft.\nSee the following example:\na.setBins(5) osc(20,.1,2) .saturate(()=\u0026gt;1-a.fft[4]) .rotate(()=\u0026gt;a.fft[0]) .kaleid() .out() See how if you make a deep \u0026ldquo;O\u0026rdquo; sound into the mic, the rotation will be strong and the saturation won\u0026rsquo;t be affected as much. Also try to make a high \u0026ldquo;S\u0026rdquo; sound, you\u0026rsquo;ll see the exact opposite.\nNote how we use brackets to call an element in an Array, and that we start counting from 0.\na.bins \u0026amp; a.prevBins # If you want the raw values from each bin without the mapping from 0 to 1, you can access them via a.bins. You can also use a.prevBins to get the bins from the previous frame.\na.setSmooth() # Sometimes the audio reactive elements react\u0026hellip; too much. You can easily get into strobe territory if you are not careful. You can smooth out the interpretation of the sound using the a.setSmooth() function. A value of 0 will be no smoothing at all, a raw input, while a value of 1 will be so smooth nothing will happen at all. Try evaluating a.setSmooth(.85) above and see how different it looks.\na.setScale() \u0026amp; a.setCutoff() # Each microphone, each sound input, etc, can be quite different in volume and dynamics. If you\u0026rsquo;re on a noisy room, your visuals could react to the noise and that\u0026rsquo;s quite annoying. Or if your mic is too low on volume, your visuals may barely react. If you ran a.show() and look at the graph, you may have noticed there are 2 horizontal lines going across the bins. The lowest one represents the cutoff (guitar players and other musicians out here might know this as a noise gate), this means that the value of the bin will be 0 unless the sound goes above that cutoff. The higher line is the scale, that\u0026rsquo;s where the maximum value of 1 is (again, musicians may want to see this as a limiter with auto-gain). If a given bin goes above the scale value, its value won\u0026rsquo;t go past 1.\na.vol # a.vol will give you the overall volume of the audio input.\na.onBeat() \u0026amp; a.beat # Hydra also has a simple beat detection algorithm. You can change this function to anything you like and it will be executed whenever Hydra detects a beat. The beat detection algorithm uses values from a.vol and compares them with a threshold set at a.beat.\na.beat stores the configuration for the beat detection Hydra uses. It\u0026rsquo;s an Object which most useful parameter is threshold. a.beat.threshold represents the volume to which a.vol will be compared to detect a beat. There\u0026rsquo;s also a.beat.decay which sets the decay after a beat.\nReacting to music # As we\u0026rsquo;ve seen, Hydra takes your microphone as an input, not your desktop audio. Those interested in using a music player or a DAW\u0026rsquo;s output as an audio input will have to delve into virtual audio routing. Users with physical sound interfaces with multiple inputs and outputs might prefer physically routing an output to an input and set that input as the default microphone on Chrome. If you use a DAW, you could also use envelope followers inside it and send MIDI CC to Hydra with the hydra-midi extension.\n"},{"id":57,"href":"/docs/docs/learning/guides/event-listeners/","title":"Clicks \u0026 keys","section":"guides","content":" Using clicks \u0026amp; keyboard presses in Hydra # by Geikha\nUsing JavaScript event listeners # Browsers have implemented in them a system of events which allows them to do X when Y happens. More concretely, this means we can define functions that will be run whenever a given event happens. Some examples of events are click (when a mouse click happens), resize (when the browser\u0026rsquo;s window is resized), keydown (when a keyboard key is pressed down), load (when the webpage and its resources have been loaded), etc. We call each function we assign to an event an \u0026ldquo;event listener\u0026rdquo;. And there are to ways to add event listeners to our Hydra instance (or in any webpage):\naddEventListener(\u0026#39;click\u0026#39;, (event) =\u0026gt; {}); onclick = (event) =\u0026gt; { }; We\u0026rsquo;ll be using the latter in the next examples since it\u0026rsquo;s shorter. The former can allow you to add many listeners for the same event, but we don\u0026rsquo;t really need that as much in Hydra, although you might find cool things to do with them! All event listeners have one parameter, which here we conveniently called event, where we receive an object representing the event and useful data about it. For example, a click event includes data about the position the click was done, if the alt or ctrl keys were pressed while clicking, etc. You can ignore it if you won\u0026rsquo;t use values from it.\nclick, pointerdown and pointerup # One of the key things you need to take into account when working with mouse and keyboard events is that every time you click, every time you press a key, there\u0026rsquo;s a pressing and a release action. These are usually named in events as \u0026lsquo;down\u0026rsquo; or \u0026lsquo;up\u0026rsquo;. For example, mousedown events happen when you start pressing the mouse button, mouseup events will happen at the release, and click events will happen when you both pressed and release the left mouse button. However, we\u0026rsquo;ll try to use PointerEvent\u0026rsquo;s\u0026rsquo; instead of MouseEvents since they are more general and work perfectly with any sort of pointer such as touch devices, drawing tablets, etc. They also allow for multi-touch input.\nToggle transforms on click # Note that in JavaScript, you can pass any value as a boolean and JavaScript will try to interpret it in some way (search for truthy and falsy if you want to learn more). With numbers, 0 will act as false and any other number will act as true. We can make use of this to generate our toggling action. Fans of bitwise operators might implement the toggle as toggle = toggle ^ 1, where ^ means XOR.\nPointer version # We can simplify a click to be simply when any pointer is released (or pressed, whichever you prefer):\nNote that this example won\u0026rsquo;t work if run after the previous one. Since both events will be triggered and the toggle will happen two times. Remember to \u0026ldquo;clean-up\u0026rdquo; any conflicting events either by reloading Hydra (remember to save doing Ctrl+Shift+L!) or simply setting the conflicting event to null. For example: onclick = null.\nActivate transforms while clicking # Note how we make use of the ternary operator again to get arbitrarily different values depending on if the user is pressing or not. You could also change these values into some other functions! or play with time.\nCount the amount of clicks # The use of ++ at the end of clicks is a shorthand in many C-like languages for something like clicks = clicks + 1. Learn more about it here\nAccumulate during clicks # In order to accumulate values while a pointer is being pressed we need to be constantly checking if it\u0026rsquo;s pressed. We can do this using JavaScript\u0026rsquo;s functionality for intervals. We could even do this with timeouts, actually. But there\u0026rsquo;s a better way of doing this, which is checking if the pointer is being pressed every time Hydra renders a frame. But let\u0026rsquo;s not get ahead of ourselves, and see the intervals version before:\npress = false onpointerdown = () =\u0026gt; { press = true } onpointerup = () =\u0026gt; { press = false } pressedTime = 0; sensitivity = 0.05; // clearInterval(interval) // uncomment after first eval interval = setInterval(()=\u0026gt;{ pressedTime += press ? sensitivity : 0 },34) osc(15,.1,()=\u0026gt;pressedTime) .out() Ok, now that we see how tedious it can be to use intervals, let\u0026rsquo;s see how we can do this in a more Hydrated way. As we just said, we could try checking if the pointer is being pressed each time Hydra renders a frame. Coincidentally, the arrows functions we love to use as arguments for our functions, are checked by Hydra every frame! We could try writing the action that updates our pressedTime inside one:\nThis works! And there\u0026rsquo;s no need to explicitly return pressedTime in our function since JavaScript can infer that\u0026rsquo;s what we want to return since it\u0026rsquo;s the last (and only) assignment we made. There\u0026rsquo;s another way of making Hydra run some functionality each frame, which is using Hydra\u0026rsquo;s update function which is discussed in the next part.\nGenerating new patches on clicks # Since outputting is simply a function call as any other. We can also try to evaluate patches when an event is triggered:\nOther mouse/pointer events # There are many other pointer events you can try to experiment with! For example pointermove is triggered whenever the pointer moves. Read more about them here\nkeydown \u0026amp; keyup # To use keyboard input, we can use KeyboardEvent\u0026rsquo;s such as keydown, keyup. These work exactly like pointerdown and pointerup, but here\u0026rsquo;s where the listener parameter we called event earlier, the one we\u0026rsquo;ve been quietly ignoring, comes into play. Since the event that we get will tell us which key was pressed! And if it was pressed while pressing Ctrl or Alt, etc. Now we can do everything we\u0026rsquo;ve been doing with the mouse buttons using any key from the keyboard! If we want to use a specific we can just use a condition and ask if the event we received is correspondent with the key we want. You can test different keys and what their events return in very handy websites such as key.js.\nMoving stuff with the arrow keys # Here either add or subtract one from our x and y values depending on which arrow key the user presses. Each representing one of the 2 dimensional axis.\nExample: Typing shapes # Here we use the keyCode of the last pressed key to change the shape being shown. This is a modification of ax example from the page about iteration. There we used ASCII codes to automatically generate shapes. However, ASCII and keyCodes of given letters are different!\n"},{"id":58,"href":"/docs/docs/learning/extending-hydra/contributing/editor/","title":"editor","section":"developing \u0026 contributing","content":" Developing editor # To run locally, you must have nodejs and npm installed. Install node and npm from: https://nodejs.org/en/.\nFirst, clone the repository\ngit clone git@github.com:hydra-synth/hydra.git enter the directory of the hydra source code:\ncd hydra Current main branch # The current main branch uses browserify to bundle the script. While new features should be implemented in dev branch, if there is a hot fix needed in the current main branch, please follow this guide.\nOnce you have node and npm installed, you can install yarn globally by running the following from the command line:\nnpm install --global yarn install dependencies:\nyarn install bundle JavaScript with browserify:\nyarn build run server\nyarn serve go to http://localhost:8000 in the browser. Congratulations! You built hydra-editor on your computer!\nWhere do these commands come from? # Yarn commands are defined in package.json.\nDevelopment # Make your new branch\ngit checkout -b my-awesome-feature Edit the code. If you want to see changes in real time, you can use the watch script. After running yarn serve, open another terminal and run\nyarn watch Then every time you save code, it will automatically re-bundle the code.\nServing on your own server # (stub)\nCommit, push and pull request # (stub)\ndev branch # New features should be implemented in dev branch. After entering the directory, checkout the branch\ngit checkout -b dev origin/dev install dependencies:\nnpm install run dev environment\nnpm run dev Since we use vite in dev branch, we don\u0026rsquo;t need to bundle the code during development (vite takes care of bundling and serving while you code). When you want to publish the code, build the bundle:\nnpm run build Connecting to server from dev/ local editor environment # This repo only contains hydra editor frontend. You can connect to a backend server (https://github.com/hydra-synth/hydra-server) for signaling and gallery functionality. To do this, set up hydra-server from above. Then create a .env file in the root of the hydra directory. Add the url of your server as a line in the .env file as:\nVITE_SERVER_URL=http://localhost:8000 (replace http://localhost:8000 with the url of your server)\nLoading local files # You can now use files on your computer as sources. Just place files you want to load in the hydra/public folder and then you can load them as usual, e.g. s0.initVideo(\u0026ldquo;myvid.mp4\u0026rdquo;)\n"},{"id":59,"href":"/docs/docs/learning/extending-hydra/contributing/synth/","title":"developing hydra-synth","section":"developing \u0026 contributing","content":" Developing synth # Clone the repository\ngit@github.com:hydra-synth/hydra-synth.git enter the folder\ncd hydra-synth install the dependencies\nnpm install build\nnpm run build The bundled code is in dist/hydra-synth.js.\nTrying on the browser # This repository does not come with the editor. However, you can use the simple example dist/index.html. To do so, install http-server\nnpm install --global http-server and serve dist folder\nhttp-server dist go to http://localhost:8000 in the browser. You can either edit the hydra code in index.html to try hydra functions, or open the developer console and type hydra code (e.g., osc().out()) and it will update the canvas. The former is useful for testing more complex examples including non-global mode, and the later is useful for quick testing.\nFor testing the integration with hydra-editor (of if you want to host your own hydra version on your server), please follow editor guide to host your own editor. Then, edit package.json in hydra (not hydra-synth) to use the local version of hydra-synth (assuming you have hydra and hydra-synth folders in the same folder)\n\u0026quot;hydra-synth\u0026quot;: \u0026quot;file:../hydra-synth\u0026quot;, Then in hydra, update the package\nnpm update hydra-synth Now the editor is using your version of hydra-synth.\n"},{"id":60,"href":"/docs/docs/learning/extending-hydra/contributing/server/","title":"backend server","section":"developing \u0026 contributing","content":" backend server # Coming soon\u0026hellip;\n"},{"id":61,"href":"/docs/posts/hydra-meetup-8/","title":"hydra meetup #8 is today!","section":"blog","content":"Join us today at 15:00UTC for hydra meetup #8! There will be talks from hydra microgrant recipients Aida El-Oweidy, David Matunda, and Vagné L., as well as a chance for show and tell.\nSignups at: https://hydra-meetup-8.glitch.me\n"},{"id":62,"href":"/docs/docs/learning_old/reference/api/array/","title":"Array","section":"API","content":" Arrays # Sequence your inputs # When you send an Array as an input, Hydra will automatically switch and jump from each element from the Array to the next one. When there are no more elements, it wraps all the way back to the beginning. Let\u0026rsquo;s see it in action:\nAs you can see, the fact that both these Arrays have a different amount of values doesn\u0026rsquo;t matter, Hydra will take values from each element of any Array for the same amount of time by default.\nThe Arrays can be passed in any way, you may have a variable that stores an Array and use its name within your sketches (not recommended in some scenarios, more info below), you may create a function that returns Arrays and use that to automatically generate discrete sequences of values:\nChanging the global bpm for Arrays # To change how rapidly Hydra switches from element to element of all Arrays, you can change the bpm variable (meaning beats per minute) to any value you desire:\nThe default value for bpm is 30.\nWhen livecoding visuals at the same time that music is playing, it can be useful to have a tapping metronome opened to keep track of the BPM being played and set this variable as such.\nChanging the speed of a specific Array # Hydra adds a couple of methods to all Arrays to be used inside Hydra. .fast will control the speed at which Hydra takes elements from the Array. It receives a Number as argument, by which the global speed will be multiplied. So calling .fast(1) on an Array is the same as nothing. Higher values will generate faster switching, while lower than 1 values will be slower.\nOffsetting the timing of an Array # Another one of the methods Hydra adds to Arrays, allows you to offset the timing at which Hydra will switch from one element of the Array to the next one. The method .offset takes a Number from 0 to 1.\nFitting the values of an Array within a range # Sometimes you have an Array whose values aren\u0026rsquo;t very useful when used as input for a some Hydra function. Hydra adds a .fit method to Arrays which takes a minimum and a maximum to which fit the values into:\nInterpolating between values # You can also interpolate between values instead of jumping from one to the other. That is, smoothly transition between values. For this you can use the .smooth method. It may take a Number argument (defaulted to 1) which controls the smoothness.\nTry smoothing some of the above examples and see what happens!\nEasing functions # The default interpolation used by Hydra on an Array that called .smooth is linear interpolation. You can select a different easing function as follows:\nThe following are the available easing functions:\nlinear: no easing, no acceleration easeInQuad: accelerating from zero velocity easeOutQuad: decelerating to zero velocity easeInOutQuad: acceleration until halfway, then deceleration easeInCubic easeOutCubic easeInOutCubic easeInQuart easeOutQuart easeInOutQuart easeInQuint easeOutQuint easeInOutQuint sin: sinusoidal shape Note on storing Arrays on variables / functions # Storing an Array in a variable can lead to some trouble as soon as you apply some of the just-mentioned functions to it. Since Arrays are Objects, each time you call your variable, you\u0026rsquo;ll be calling the same Object. If you apply some speed via .fast or smoothness via .smooth somewhere in your patch, and then use the same variable, all the following uses of the Array will also have these effects applied to them. For example\nNote on Arrays and textures # Note that the following will not work:\nsolid(1,.5,0) .diff([osc(),noise()]) .out() Hydra can\u0026rsquo;t handle Arrays of textures. You can work around it in some ways:\nUnfortunately, if you want to use many textures this solution doesn\u0026rsquo;t really apply.\nUsers of Hydra have come up with some experimental solutions which might come in handy in some scenarios, but they come with some drawbacks:\n// blending method, heavy GPU load. // every element from the array will be rendered even if not shown. // allows for blending between elements. select = function(arr,l=0){ const clamp = (num, min, max) =\u0026gt; Math.min(Math.max(num, min), max) const blending = (l,i)=\u0026gt; (clamp(l-(i-1),0,1)) const isFunction = (typeof l === \u0026#39;function\u0026#39;) return arr.reduce((prev,curr,i)=\u0026gt; prev.blend(curr, isFunction ? ()=\u0026gt;blending(l(),i) : blending(l,i)) ) } textures = [noise(), osc(), voronoi(), gradient()] select(textures,()=\u0026gt;Math.floor(mouse.x/innerWidth*4)) .out() // re-compiling method, heavy CPU load. // it reserves an output for the switching. // can\u0026#39;t blend between elements. // each time an element switches the shader must be recompiled osc(20) .rotate() .modulate(o3,.2) .out() textures = [noise(), osc(), voronoi(), shape()] index = 0 tex = textures[index] update = (dt)=\u0026gt; { if(time % (60 / bpm) * 1000 \u0026lt; dt){ index++; index %= textures.length; tex = textures[index] tex.out(o3) } } --- available methods for Arrays # fast # fast( speed = 1 )\nsmooth # smooth( smooth = 1 )\nease # ease( ease = \u0026rsquo;linear\u0026rsquo; )\noffset # offset( offset = 0.5 )\nfit # fit( low = 0, high = 1 )\n"},{"id":63,"href":"/docs/docs/learning_old/reference/api/combine/","title":"Blend","section":"API","content":" Blend # add # add( texture, amount = 1 )\nAdd textures. The texture parameter can be any kind of source, for example a color, src, or shape.\nsub # sub( texture, amount = 1 )\nlayer # layer( texture )\nOverlay texture based on alpha value. The texture parameter can be any kind of source, for example a color, src, or shape.\nblend # blend( texture, amount = 0.5 )\nBlend textures. The texture parameter can be any kind of source, for example a color, src, or shape.\nmult # mult( texture, amount = 1 )\nMultiply images and blend with the texture by amount. The texture parameter can be any kind of source, for example a color, src, or shape.\ndiff # diff( texture )\nReturn difference of textures. The texture parameter can be any kind of source, for example a color, src, or shape.\nmask # mask( texture )\n"},{"id":64,"href":"/docs/docs/learning_old/reference/api/combinecoord/","title":"Modulate","section":"API","content":" Modulate # modulateRepeat # modulateRepeat( texture, repeatX = 3, repeatY = 3, offsetX = 0.5, offsetY = 0.5 )\nThe texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateRepeatX # modulateRepeatX( texture, reps = 3, offset = 0.5 )\nThe texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateRepeatY # modulateRepeatY( texture, reps = 3, offset = 0.5 )\nThe texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateKaleid # modulateKaleid( texture, nSides = 4 )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: kaleid.\nmodulateScrollX # modulateScrollX( texture, scrollX = 0.5, speed )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: scrollX\nmodulateScrollY # modulateScrollY( texture, scrollY = 0.5, speed )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: scrollY\nmodulate # modulate( texture, amount = 0.1 )\nModulate texture. More about modulation at: https://lumen-app.com/guide/modulation/ The texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateScale # modulateScale( texture, multiple = 1, offset = 1 )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: scale.\nmodulatePixelate # modulatePixelate( texture, multiple = 10, offset = 3 )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: pixelate\nmodulateRotate # modulateRotate( texture, multiple = 1, offset )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: rotate\nmodulateHue # modulateHue( texture, amount = 1 )\nChanges coordinates based on hue of second input. Based on: https://www.shadertoy.com/view/XtcSWM The texture parameter can be any kind of source, for example a color, src, or shape.\n"},{"id":65,"href":"/docs/docs/learning_old/reference/api/settings/","title":"Synth Settings","section":"API","content":" Synth Settings # Functions and settings that affect overall hydra behavor and rendering.\nrender # render( texture = all )\n// default osc(30,0.1,1.5).out(o0) noise().out(o1) solid(1).out(o2) gradient().out(o3) render() update # update( )\nsetResolution # setResolution( width, height )\n// make the canvas small (100 pixel x 100 pixel) setResolution(100,100) osc().out(o0) hush # hush( )\n// clear the buffers osc().out(o0) hush() setFunction # setFunction( options )\nspeed # speed = 1\nbpm # bpm = 30\nwidth # width\nheight # height\ntime # time\nmouse # mouse = { x, y }\n"},{"id":66,"href":"/docs/contributing_code/","title":"Contributing Code","section":"hydra video synth: documentation portal","content":" Contributing Code # Running locally # To run locally, you must have nodejs, yarn and npm installed. Install node and npm from: https://nodejs.org/en/\nInstall yarn from the command line\nnpm install --global yarn open terminal and enter directory\ncd hydra install dependencies:\nyarn install run server\nyarn serve go to https://localhost:8000 in the browser\nTo develop # Edit frontend/public/index.html to load \u0026lsquo;bundle.js\u0026rsquo; rather than \u0026lsquo;bundle.min.js\u0026rsquo;\nRun development server\nyarn dev "},{"id":67,"href":"/docs/contributing_translation/","title":"Contributing Translation","section":"hydra video synth: documentation portal","content":" Contributing Translation # Everyone is welcome to contribute translations - such as improvement of the existing pages, writing original contents and adding a new language support :)\nType of Documents # hydra-documents: Guides and this document, which can be found at https://hydra.ojack.xyz/docs/ hydra-functions: the API reference, which can be found at https://hydra.ojack.xyz/api/ hydra editor: the main editor https://hydra.ojack.xyz/ hydra-documents # hydra-documents are accessible at https://hydra.ojack.xyz/docs/ and the contents are hosted on GitHub. In short, if you edit files on GitHub, they will be updated on the website (the first link).\nHere we assume you are familiar with Git. If you are not familiar with it and want to make suggestions, don\u0026rsquo;t worry - for small changes like typo, feel free to use \u0026ldquo;Edit this file\u0026rdquo; button on GitHub or open an issue so someone can make the edit!\nFork and clone the repository https://github.com/hydra-synth/hydra-docs If the language you contribute is not supported at all, create a folder with language code (e.g., /ja for Japanese). At the moment we don\u0026rsquo;t use region code (e.g., fr-ca for French Canadian) - but feel free to suggest if that is necessary! For translating articles existing in English (e.g., getting_started.md), create a file under the language folder with the same name (e.g., /ja/getting_started.md). For original contents, feel free to name it as you like :) Translate the document!\nTip 1: files are written in markdown format. It\u0026rsquo;s important to keep the same structure as the English one (like ## tag for headings). If you couldn\u0026rsquo;t finish translating the whole file, leave remaining headings and texts in English so someone else or you can continue editing later.\nTip 2: code blocks should have javascript tag as seen in the files in English so that they will be rendered with an embedded editor. Feel free to add your name and contact to the translated file :) Add a hyperlink to the file to /_sidebar.md - the translated contents go under a bullet point of the language (e.g., Japanese | 日本語). Otherwise, your contributed file won\u0026rsquo;t appear on the sidebar :( Make a git commit and push it to your GitHub repository! Create a pull request. We try our best to merge the edits as soon as possible! hydra-functions # hydra-functions are accessible at https://hydra.ojack.xyz/api/ and the contents are hosted on GitHub. Currently, you need to manually build the javascript bundle.\nstub:\nClone and fork the repository npm install edit here https://github.com/hydra-synth/hydra-functions/blob/main/locales.js for examples, edit here https://github.com/hydra-synth/hydra-functions/blob/main/examples.js npm run build commit, push, PR hydra editor # currently not supported\n"},{"id":68,"href":"/docs/docs/learning_old/interactivity/arrays/","title":"Arrays","section":"Sequencing \u0026 interactivity","content":" Arrays # Sequence your inputs # When you send an Array as an input, Hydra will automatically switch and jump from each element from the Array to the next one. When there are no more elements, it wraps all the way back to the beginning. Let\u0026rsquo;s see it in action:\nAs you can see, the fact that both these Arrays have a different amount of values doesn\u0026rsquo;t matter, Hydra will take values from each element of any Array for the same amount of time by default.\nThe Arrays can be passed in any way, you may have a variable that stores an Array and use its name within your sketches (not recommended in some scenarios, more info below), you may create a function that returns Arrays and use that to automatically generate discrete sequences of values:\nChanging the global bpm for Arrays # To change how rapidly Hydra switches from element to element of all Arrays, you can change the bpm variable (meaning beats per minute) to any value you desire:\nThe default value for bpm is 30.\nWhen livecoding visuals at the same time that music is playing, it can be useful to have a tapping metronome opened to keep track of the BPM being played and set this variable as such.\nChanging the speed of a specific Array # Hydra adds a couple of methods to all Arrays to be used inside Hydra. .fast will control the speed at which Hydra takes elements from the Array. It receives a Number as argument, by which the global speed will be multiplied. So calling .fast(1) on an Array is the same as nothing. Higher values will generate faster switching, while lower than 1 values will be slower.\nOffsetting the timing of an Array # Another one of the methods Hydra adds to Arrays, allows you to offset the timing at which Hydra will switch from one element of the Array to the next one. The method .offset takes a Number from 0 to 1.\nFitting the values of an Array within a range # Sometimes you have an Array whose values aren\u0026rsquo;t very useful when used as input for a some Hydra function. Hydra adds a .fit method to Arrays which takes a minimum and a maximum to which fit the values into:\nInterpolating between values # You can also interpolate between values instead of jumping from one to the other. That is, smoothly transition between values. For this you can use the .smooth method. It may take a Number argument (defaulted to 1) which controls the smoothness.\nTry smoothing some of the above examples and see what happens!\nEasing functions # The default interpolation used by Hydra on an Array that called .smooth is linear interpolation. You can select a different easing function as follows:\nThe following are the available easing functions:\nlinear: no easing, no acceleration easeInQuad: accelerating from zero velocity easeOutQuad: decelerating to zero velocity easeInOutQuad: acceleration until halfway, then deceleration easeInCubic easeOutCubic easeInOutCubic easeInQuart easeOutQuart easeInOutQuart easeInQuint easeOutQuint easeInOutQuint sin: sinusoidal shape Note on storing Arrays on variables / functions # Storing an Array in a variable can lead to some trouble as soon as you apply some of the just-mentioned functions to it. Since Arrays are Objects, each time you call your variable, you\u0026rsquo;ll be calling the same Object. If you apply some speed via .fast or smoothness via .smooth somewhere in your patch, and then use the same variable, all the following uses of the Array will also have these effects applied to them. For example\nNote on Arrays and textures # Note that the following will not work:\nsolid(1,.5,0) .diff([osc(),noise()]) .out() Hydra can\u0026rsquo;t handle Arrays of textures. You can work around it in some ways:\nUnfortunately, if you want to use many textures this solution doesn\u0026rsquo;t really apply.\nUsers of Hydra have come up with some experimental solutions which might come in handy in some scenarios, but they come with some drawbacks:\n// blending method, heavy GPU load. // every element from the array will be rendered even if not shown. // allows for blending between elements. select = function(arr,l=0){ const clamp = (num, min, max) =\u0026gt; Math.min(Math.max(num, min), max) const blending = (l,i)=\u0026gt; (clamp(l-(i-1),0,1)) const isFunction = (typeof l === \u0026#39;function\u0026#39;) return arr.reduce((prev,curr,i)=\u0026gt; prev.blend(curr, isFunction ? ()=\u0026gt;blending(l(),i) : blending(l,i)) ) } textures = [noise(), osc(), voronoi(), gradient()] select(textures,()=\u0026gt;Math.floor(mouse.x/innerWidth*4)) .out() // re-compiling method, heavy CPU load. // it reserves an output for the switching. // can\u0026#39;t blend between elements. // each time an element switches the shader must be recompiled osc(20) .rotate() .modulate(o3,.2) .out() textures = [noise(), osc(), voronoi(), shape()] index = 0 tex = textures[index] update = (dt)=\u0026gt; { if(time % (60 / bpm) * 1000 \u0026lt; dt){ index++; index %= textures.length; tex = textures[index] tex.out(o3) } } "},{"id":69,"href":"/docs/docs/learning_old/interactivity/audio/","title":"Audio","section":"Sequencing \u0026 interactivity","content":" Audio reactivity # FFT functionality is available via an audio object accessed via \u0026ldquo;a\u0026rdquo;. The editor uses https://github.com/meyda/meyda for audio analysis. To show the fft bins,\na.show() Set number of fft bins:\na.setBins(6) Access the value of the leftmost (lowest frequency) bin:\na.fft[0] Use the value to control a variable:\nosc(10, 0, () =\u0026gt; a.fft[0]*4) .out() It is possible to calibrate the responsiveness by changing the minimum and maximum value detected. (Represented by blur lines over the fft). To set minimum value detected:\na.setCutoff(4) Setting the scale changes the range that is detected.\na.setScale(2) The fft[] will return a value between 0 and 1, where 0 represents the cutoff and 1 corresponds to the maximum.\nYou can set smoothing between audio level readings (values between 0 and 1). 0 corresponds to no smoothing (more jumpy, faster reaction time), while 1 means that the value will never change.\na.setSmooth(0.8) To hide the audio waveform:\na.hide() a.setBins(5) // amount of bins (bands) to separate the audio spectrum noise(2) .modulate(o0,()=\u0026gt;a.fft[1]*.5) // listening to the 2nd band .out() a.setSmooth(.8) // audio reactivity smoothness from 0 to 1, uses linear interpolation a.setScale(8) // loudness upper limit (maps to 0) a.setCutoff(0.1) // loudness from which to start listening to (maps to 0) a.show() // show what hydra\u0026#39;s listening to // a.hide() render(o0) "},{"id":70,"href":"/docs/docs/learning_old/interactivity/midi/","title":"Midi","section":"Sequencing \u0026 interactivity","content":" MIDI # Hydra can be used with Web MIDI for an extra layer of control to your visuals.\nExample script: browser console # At this time this requires some running of code on the browser console (Press F12 in Chrome to access). This page only considers MIDI Continuous Controllers (CC) but other types of data may be accessible.\nThis is a generic script that doesn\u0026rsquo;t care what Midi Channel you\u0026rsquo;re broadcasting on and maps a normalized value 0.0-1.0 into an array named cc.\nThis portion should be ran in the console \u0026amp; will register Web MIDI \u0026amp; map the incoming CC data to a set of parameters. For simplicity, these parameters are named to match the CC number. The CC values are normally in a range from 0-127, but we\u0026rsquo;ve also normalized them to be in a range of 0.0-1.0.\n// register WebMIDI navigator.requestMIDIAccess() .then(onMIDISuccess, onMIDIFailure); function onMIDISuccess(midiAccess) { console.log(midiAccess); var inputs = midiAccess.inputs; var outputs = midiAccess.outputs; for (var input of midiAccess.inputs.values()){ input.onmidimessage = getMIDIMessage; } } function onMIDIFailure() { console.log(\u0026#39;Could not access your MIDI devices.\u0026#39;); } //create an array to hold our cc values and init to a normalized value var cc=Array(128).fill(0.5) getMIDIMessage = function(midiMessage) { var arr = midiMessage.data var index = arr[1] //console.log(\u0026#39;Midi received on cc#\u0026#39; + index + \u0026#39; value:\u0026#39; + arr[2]) // uncomment to monitor incoming Midi var val = (arr[2]+1)/128.0 // normalize CC values to 0.0 - 1.0 cc[index]=val } Hydra script # Now that these controls have been assigned to the cc[] array, we can start using them in Hydra. As we\u0026rsquo;ve normalized the values 0-1 we can use as-is with most functions or quickly remap them with various math.\n// example midi mappings - Korg NanoKontrol2 CCs // color controls with first three knobs noise(4).color( ()=\u0026gt;cc[16], ()=\u0026gt;cc[17], ()=\u0026gt;cc[18] ).out() // rotate \u0026amp; scale with first two faders osc(10,0.2,0.5).rotate( ()=\u0026gt;(cc[0]*6.28)-3.14 ).scale( ()=\u0026gt;(cc[1]) ).out() MIDI extension # "},{"id":71,"href":"/docs/docs/learning_old/reference/api/","title":"API","section":"learning","content":""},{"id":72,"href":"/docs/docs/learning_old/reference/api/audio/","title":"Audio","section":"API","content":" Audio reactivity # FFT functionality is available via an audio object accessed via \u0026ldquo;a\u0026rdquo;. The editor uses https://github.com/meyda/meyda for audio analysis. To show the fft bins,\na.show() Set number of fft bins:\na.setBins(6) Access the value of the leftmost (lowest frequency) bin:\na.fft[0] Use the value to control a variable:\nosc(10, 0, () =\u0026gt; a.fft[0]*4) .out() It is possible to calibrate the responsiveness by changing the minimum and maximum value detected. (Represented by blur lines over the fft). To set minimum value detected:\na.setCutoff(4) Setting the scale changes the range that is detected.\na.setScale(2) The fft[] will return a value between 0 and 1, where 0 represents the cutoff and 1 corresponds to the maximum.\nYou can set smoothing between audio level readings (values between 0 and 1). 0 corresponds to no smoothing (more jumpy, faster reaction time), while 1 means that the value will never change.\na.setSmooth(0.8) To hide the audio waveform:\na.hide() a.setBins(5) // amount of bins (bands) to separate the audio spectrum noise(2) .modulate(o0,()=\u0026gt;a.fft[1]*.5) // listening to the 2nd band .out() a.setSmooth(.8) // audio reactivity smoothness from 0 to 1, uses linear interpolation a.setScale(8) // loudness upper limit (maps to 0) a.setCutoff(0.1) // loudness from which to start listening to (maps to 0) a.show() // show what hydra\u0026#39;s listening to // a.hide() render(o0) available Audio methods # fft # fft = Array(4)\n// default osc().modulate(noise(3),()=\u0026gt;a.fft[0]).out(o0) setSmooth # setSmooth( smooth = 0.4 )\n// default a.setSmooth(0.8) osc().modulate(noise(3),()=\u0026gt;a.fft[0]).out(o0) setCutoff # setCutoff( cutoff = 2 )\n// threshold a.setCutoff(4) osc().modulate(noise(3),()=\u0026gt;a.fft[0]).out(o0) setBins # setBins( numBins = 4 )\n// change color with hissing noise a.setBins(8) osc(60,0.1,()=\u0026gt;a.fft[7]*3).modulate(noise(3),()=\u0026gt;a.fft[0]).out(o0) setScale # setScale( scale = 10 )\n// the smaller the scale is, the bigger the output is a.setScale(5) osc().modulate(noise(3),()=\u0026gt;a.fft[0]).out(o0) hide # hide( )\nshow # show( )\n"},{"id":73,"href":"/docs/docs/learning_tutorial/guides/guides/frames-and-timing/","title":"Frames and Timing","section":"Guides","content":" frames and timing # by geikha\nUsing the update function # There\u0026rsquo;s a function in the Hydra API called update. This function runs at the beginning of every frame render right before the values for time and a.fft are calculated. If you are familiar with Processing or p5, you can think of update as Hydra\u0026rsquo;s equivalent to the draw function. Using update can be very useful for creating generative visuals (generative in the sense of controlling visual elements with values that evolve through time either randomly or following certain rules). It can also be used to have a finer and/or connected control over parameters when compared to using simple arrow functions as arguments. It is also worth noting that the function receives a dt argument, which contains the delta time elapsed between the rendering of the previous frame and the current one. You may or may not want to use this to control your visuals (most of the examples don\u0026rsquo;t use it, actually).\nExamples # Using update and time to have complex control of parameters through time # The structure time % every \u0026lt; duration is super useful to make stuff happen every certain amount of seconds, for a given duration (also in seconds). time % wavelength / wavelength can be interpreted as a sawtooth wave with a given wavelength. This would generate an ascending sawtooth going from 0 to 1 in the amount of time specified by whe wavelength. For a descending one you can write something like 1-(time % wavelength / wavelength). If you want values from 0 to wavelength just remove the division.\nAdding a frame counter to make frame-specific actions # Having something appear for only one frame can be super useful in many feedback-based sketches:\nRandomly evolving values through time (Random walker) # update vs Arrow functions # Every function that you use as an argument is evaluated right before the current frame is about to be rendered. Which is the same thing that happens with the update function! This means, unless we use dt, everything we can do on update we can technically do on argument functions. It\u0026rsquo;s up for us to decide when one\u0026rsquo;s better than the other. If we are controlling many interconnected variables and procedures, most probably, an arrow function or a named function won\u0026rsquo;t be that nice to use. It\u0026rsquo;ll be confusing as to why a function which is supposed to represent a simple dynamic argument is doing so much stuff inside of itself. Maybe we could separate the different behaviors into many arrow functions. But if these functions were to feed from each other, this will yet again get confusing quite rapidly. Even then, there are many scenarios where an arrow function can do the same work as the update function with less code. For example, here\u0026rsquo;s a patch where a circle chases your mouse:\n"},{"id":74,"href":"/docs/docs/learning_tutorial/guides/hydra-garden/","title":"Hydra Garden","section":"More Resources","content":""},{"id":75,"href":"/docs/docs/learning_tutorial/next-steps/hydra-in-a-webpage/","title":"Hydra in a Webpage","section":"Next Steps","content":" Hydra-Synth # In addition to using hydra within the hydra web editor, it is also possible to use the hydra video-synth engine as a library within your own javascript projects.\nhydra-synth is a javascript library containing the main logic of hydra packaged as a javascript module.\nTo include in a webpage (bundled version): # Include the bundled version of hydra-synth in your html file:\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/hydra-synth/dist/hydra-synth.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // create a new hydra-synth instance var hydra = new Hydra({ detectAudio: false }) osc(4, 0.1, 1.2).out() \u0026lt;/script\u0026gt; You can see and remix a live example here: https://glitch.com/edit/#!/hydra-webpage\nTo use as a module: # Download the module:\nnpm install --save hydra-synth Include in your app:\nimport Hydra from \u0026#39;hydra-synth\u0026#39; const hydra = new Hydra({ detectAudio: false }) osc(4, 0.1, 1.2).out() To use using cjs/require syntax: # const Hydra = require(\u0026#39;hydra-synth\u0026#39;) The rest of this README is about configuring hydra-synth. For broader hydra documentation and usage, see learning hydra\nAPI: # const hydra = new Hydra([opts]) create a new hydra instance\nIf opts is specified, the default options (shown below) will be overridden.\n{ canvas: null, // canvas element to render to. If none is supplied, a canvas will be created and appended to the screen width: // defaults to canvas width when included, 1280 if not height: // defaults to canvas height when included, 720 if not autoLoop: true, // if true, will automatically loop using requestAnimationFrame.If set to false, you must implement your own loop function using the tick() method (below) makeGlobal: true, // if false, will not pollute global namespace (note: there are currently bugs with this) detectAudio: true, // recommend setting this to false to avoid asking for microphone numSources: 4, // number of source buffers to create initially numOutputs: 4, // number of output buffers to use. Note: untested with numbers other than 4. render() method might behave unpredictably extendTransforms: [] // An array of transforms to be added to the synth, or an object representing a single transform precision: null // force precision of shaders, can be \u0026#39;highp\u0026#39;, \u0026#39;mediump\u0026#39;, or \u0026#39;lowp\u0026#39; (recommended for ios). When no precision is specified, will use highp for ios, and mediump for everything else. pb = null, // instance of rtc-patch-bay to use for streaming } Custom render loop # You can use your own render loop for triggering hydra updates, instead of the automatic looping. To use, set autoLoop to false, and call\nhydra.tick(dt) where dt is the time elapsed in milliseconds since the last update\nTo develop: # npm run dev Sets up an example using hydra-synth that is automatically updated when source files are updated. It is possible to write test code by editing /example/index.js or by writing hydra code into the developer console.\nNon-global mode # If makeGlobal is set to false, buffers and functions can be accessed via the synth property of the hydra instance.\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().rotate().out() In non-global mode, it is important to start all hydra functions, buffers, and variables by referencing the instance of hydra synth you are currently using.e.g.\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().diff(h.shape()).out() h.gradient().out(h.o1) h.render() This also makes it possible to use more than one hydra canvas at once:\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().diff(h.shape()).out() h.gradient().out(h.o1) h.render() const h2 = new Hydra({ makeGlobal: false, detectAudio: false }).synth h2.shape(4).diff(h2.osc(2, 0.1, 1.2)).out() See https://glitch.com/edit/#!/multi-hydra for a working example of multiple hydra canvases, created by Naoto Hieda.\nIf you would like to keep the same syntax as hydra in non-global mode, consider destructuring the object further:\nconst { src, osc, gradient, shape, voronoi, noise, s0, s1, s2, s3, o0, o1, o2, o3, render } = hydra shape(4).diff(osc(2, 0.1, 1.2)).out() hydra-ts is a fork of hydra-synth in Typescript maintained by @folz.\nKnown issues / troubleshooting # Vite # When using hydra with Vite, you might see the error\nAutoplay on iOS # from issue https://github.com/hydra-synth/hydra-synth/issues/137\nIt seems on mobile safari, videos won\u0026rsquo;t autoplay because of several reasons:\nyou need playsinline attribute (which can be added programmatically) https://stackoverflow.com/questions/43570460/html5-video-autoplay-on-iphone If the \u0026lt;video\u0026gt; element is not rendered on screen, the video does not update. As a workaround, you can make a small render of the video in a corner and this seems to work \u0026lt;video style=\u0026#34;position:static;top:1px;width:1px;height:1px\u0026#34; id=\u0026#34;vid\u0026#34; autoplay loop muted playsinline crossorigin\u0026gt; \u0026lt;source src=\u0026#34;https://cdn.glitch.global/8df667c3-e544-4cbb-8c16-f604238e8d2e/paper.mov?v=1682418858521\u0026#34;\u0026gt; \u0026lt;/video\u0026gt; let v = document.getElementById(\u0026#34;vid\u0026#34;) v.addEventListener(\u0026#39;loadeddata\u0026#39;, () =\u0026gt; { s0.init({src: v}) }) Here is a live example: https://glitch.com/edit/#!/hydra-video-autoplay-ios\n"},{"id":76,"href":"/docs/docs/learning_tutorial/next-steps/interactivity/audio/","title":"Audio","section":"Interactivity: mouse, audio, and MIDI","content":" Audio reactivity # FFT functionality is available via an audio object accessed via \u0026ldquo;a\u0026rdquo;. The editor uses https://github.com/meyda/meyda for audio analysis. To show the fft bins,\na.show() Set number of fft bins:\na.setBins(6) Access the value of the leftmost (lowest frequency) bin:\na.fft[0] Use the value to control a variable:\nosc(10, 0, () =\u0026gt; a.fft[0]*4) .out() It is possible to calibrate the responsiveness by changing the minimum and maximum value detected. (Represented by blur lines over the fft). To set minimum value detected:\na.setCutoff(4) Setting the scale changes the range that is detected.\na.setScale(2) The fft[] will return a value between 0 and 1, where 0 represents the cutoff and 1 corresponds to the maximum.\nYou can set smoothing between audio level readings (values between 0 and 1). 0 corresponds to no smoothing (more jumpy, faster reaction time), while 1 means that the value will never change.\na.setSmooth(0.8) To hide the audio waveform:\na.hide() a.setBins(5) // amount of bins (bands) to separate the audio spectrum noise(2) .modulate(o0,()=\u0026gt;a.fft[1]*.5) // listening to the 2nd band .out() a.setSmooth(.8) // audio reactivity smoothness from 0 to 1, uses linear interpolation a.setScale(8) // loudness upper limit (maps to 0) a.setCutoff(0.1) // loudness from which to start listening to (maps to 0) a.show() // show what hydra\u0026#39;s listening to // a.hide() render(o0) "},{"id":77,"href":"/docs/docs/learning_tutorial/next-steps/interactivity/midi/","title":"Midi","section":"Interactivity: mouse, audio, and MIDI","content":" MIDI # Hydra can be used with Web MIDI for an extra layer of control to your visuals.\nExample script: browser console # At this time this requires some running of code on the browser console (Press F12 in Chrome to access). This page only considers MIDI Continuous Controllers (CC) but other types of data may be accessible.\nThis is a generic script that doesn\u0026rsquo;t care what Midi Channel you\u0026rsquo;re broadcasting on and maps a normalized value 0.0-1.0 into an array named cc.\nThis portion should be ran in the console \u0026amp; will register Web MIDI \u0026amp; map the incoming CC data to a set of parameters. For simplicity, these parameters are named to match the CC number. The CC values are normally in a range from 0-127, but we\u0026rsquo;ve also normalized them to be in a range of 0.0-1.0.\n// register WebMIDI navigator.requestMIDIAccess() .then(onMIDISuccess, onMIDIFailure); function onMIDISuccess(midiAccess) { console.log(midiAccess); var inputs = midiAccess.inputs; var outputs = midiAccess.outputs; for (var input of midiAccess.inputs.values()){ input.onmidimessage = getMIDIMessage; } } function onMIDIFailure() { console.log(\u0026#39;Could not access your MIDI devices.\u0026#39;); } //create an array to hold our cc values and init to a normalized value var cc=Array(128).fill(0.5) getMIDIMessage = function(midiMessage) { var arr = midiMessage.data var index = arr[1] //console.log(\u0026#39;Midi received on cc#\u0026#39; + index + \u0026#39; value:\u0026#39; + arr[2]) // uncomment to monitor incoming Midi var val = (arr[2]+1)/128.0 // normalize CC values to 0.0 - 1.0 cc[index]=val } Hydra script # Now that these controls have been assigned to the cc[] array, we can start using them in Hydra. As we\u0026rsquo;ve normalized the values 0-1 we can use as-is with most functions or quickly remap them with various math.\n// example midi mappings - Korg NanoKontrol2 CCs // color controls with first three knobs noise(4).color( ()=\u0026gt;cc[16], ()=\u0026gt;cc[17], ()=\u0026gt;cc[18] ).out() // rotate \u0026amp; scale with first two faders osc(10,0.2,0.5).rotate( ()=\u0026gt;(cc[0]*6.28)-3.14 ).scale( ()=\u0026gt;(cc[1]) ).out() MIDI extension # "},{"id":78,"href":"/docs/docs/community/","title":"community","section":"Docs","content":" community projects, libraries, and resources # "},{"id":79,"href":"/docs/docs/learning_tutorial/next-steps/glsl/","title":"Custom GLSL","section":"Next Steps","content":" GLSL Guide # Using custom GLSL functions # Those more experienced with Hydra and/or digital visuals in general, might know that Hydra is built on WebGL and its shadering language, GLSL ES. Hydra has a unique way of adding custom source and transform functions which we will explain here.\nsetFunction # The Hydra API includes a function called setFunction which receives a specific type of JavaScript object. This object will have the properties name, type, inputs and glsl.\nname is a String with the name for the function type is one of the available types of functions (\u0026lsquo;src\u0026rsquo;, \u0026lsquo;color\u0026rsquo;, \u0026lsquo;coord\u0026rsquo;, \u0026lsquo;combine\u0026rsquo;, \u0026lsquo;combineCoord\u0026rsquo;) inputs is an Array of objects each with it\u0026rsquo;s own name, type and default properties. They represent the arguments of the GLSL function. glsl is a String with the glsl code. Example # setFunction({ name: \u0026#39;myOsc\u0026#39;, type: \u0026#39;src\u0026#39;, inputs: [ { name: \u0026#39;freq\u0026#39;, type: \u0026#39;float\u0026#39;, default: 20 } ], glsl: ` return vec4(sin((_st.x+time)*freq*vec3(0.1)),1.0); ` }) Types of GLSL functions and their arguments # src # A function with a specified type of src is one that generates visuals by its own. Just like osc or noise. They all have a vec2 argument called _st for the coordinate. And you can add any custom inputs as shown above. You must return a vec4.\ncolor # A color function receives a vec4 called _c0 that represents the color being affected by the transform. As any function you may add any extra inputs. You must return another vec4.\ncoord # A coord function receives a vec2 called _st that represents the coordinate plane. You must return another vec2.\ncombine # The functions of type combine receive 2 vec4 arguments, _c0 and _c1. The first one represents the texture being affected and the latter represents the texture being blended into the former. For example, when you use osc().mult(noise()), inside the definition of the function, _c0 represents the osc() and _c1 represents the noise() colors. You can think combine functions as blending modes. And as custom function you may add extra inputs as needed. You must return a vec4.\ncombineCoord # combineCoord functions change the position of colors in the texture being affected given the colors of another texture. Think about the many modulate functions for example, since they are precisely this type. They receive a vec2 _st and a vec4 _c0. You must return a vec2.\nBuilt in functions you can use # The following functions are pre-defined for every Hydra generated shader, and in the same way that some built-in functions use them, you may too:\n_luminance # float _luminance(vec3 rgb){ const vec3 W = vec3(0.2125, 0.7154, 0.0721); return dot(rgb, W); } Returns the luminance of a given rgb color.\n_rgb2Hsv # vec3 _rgbToHsv(vec3 c){ vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r)); float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); } Transforms a color from the rgb to the hsv colorspace.\n_hsv2Rgb # vec3 _hsvToRgb(vec3 c){ vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); } Transforms a color from the hsv colorspace back to rgb.\nNote # As of now there is no way to define \u0026ldquo;global\u0026rdquo; functions such as these ones just mentioned. But expect it soon!\nExamples # Chroma Key # This example modifies color to replace green background with transparency (i.e., chroma keying). The GLSL code is ported from Inigo Quilez\u0026rsquo;s example.\nsetFunction({ name: \u0026#39;chroma\u0026#39;, type: \u0026#39;color\u0026#39;, inputs: [ ], glsl: ` float maxrb = max( _c0.r, _c0.b ); float k = clamp( (_c0.g-maxrb)*5.0, 0.0, 1.0 ); float dg = _c0.g; _c0.g = min( _c0.g, maxrb*0.8 ); _c0 += vec4(dg - _c0.g); return vec4(_c0.rgb, 1.0 - k); `}) // s0.initCam() // src(s0).out(o0) solid(0,1,0).layer(shape(5,0.3,0.3).luma()).out(o0) osc(30, 0, 1).layer(src(o0).chroma()).out(o1) render() GLSL Injection # Since Hydra runs GLSL on the background, and everything you input into the parameters of the different functions ends up written on GLSL (be it literally or as a uniform), you can sort of hack Hydra (and totally break it) by sending strings of GLSL expressions as arguments:\nThe reason you can \u0026ldquo;totally break Hydra\u0026rdquo; here is that Hydra works with a modular flow. In order for it to work, when you do coordinate transforms after a bunch of interconnected textures, these transforms must apply to all coordinate references in the shader. If you inject values of the st coordinates in your arguments, Hydra has no way of applying any further transforms to them, therefore breaking the modularity.\nExtensions # Extra shaders # There are some Hydra extensions that load many custom glsl functions, such as:\nextra-shaders-for-hydra hydra-blending-modes Extra Functionality # The hydra-glsl extension allows you to write GLSL directly in your patches. For example:\nglsl(\u0026#39;vec4(sin(((_st.x*54.)+time*2.)*vec3(0.1,0.102,0.101)),1.0)\u0026#39;) .diff(o0) .glslColor(\u0026#39;vec4(c0.brg,1.)\u0026#39;) .glslCoord(\u0026#39;xy*=(1.0/vec2(i0, i0)); return xy\u0026#39;,.25) .glslCombine(\u0026#39;c0-c1\u0026#39;,o1) .glslCombineCoord(\u0026#39;uv+(vec2(c0.r,c0.b)*0.1)\u0026#39;,o1) .out() "},{"id":80,"href":"/docs/docs/learning/guides/how-to/hydra-in-a-webpage/","title":"Embed Hydra on your webpage","section":"How to...","content":" Embed Hydra on your webpage # By Olivia Jack\nIn addition to using hydra within the hydra web editor, it is also possible to use the hydra video-synth engine as a library within your own javascript projects.\nhydra-synth is a javascript library containing the main logic of hydra packaged as a javascript module.\nTo include in a webpage (bundled version): # Include the bundled version of hydra-synth in your html file:\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/hydra-synth/dist/hydra-synth.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // create a new hydra-synth instance var hydra = new Hydra({ detectAudio: false }) osc(4, 0.1, 1.2).out() \u0026lt;/script\u0026gt; You can see and remix a live example here: https://glitch.com/edit/#!/hydra-webpage\nTo use as a module: # Download the module:\nnpm install --save hydra-synth Include in your app:\nimport Hydra from \u0026#39;hydra-synth\u0026#39; const hydra = new Hydra({ detectAudio: false }) osc(4, 0.1, 1.2).out() To use using cjs/require syntax: # const Hydra = require(\u0026#39;hydra-synth\u0026#39;) The rest of this README is about configuring hydra-synth. For broader hydra documentation and usage, see learning hydra\nAPI: # const hydra = new Hydra([opts]) create a new hydra instance\nIf opts is specified, the default options (shown below) will be overridden.\n{ canvas: null, // canvas element to render to. If none is supplied, a canvas will be created and appended to the screen width: // defaults to canvas width when included, 1280 if not height: // defaults to canvas height when included, 720 if not autoLoop: true, // if true, will automatically loop using requestAnimationFrame.If set to false, you must implement your own loop function using the tick() method (below) makeGlobal: true, // if false, will not pollute global namespace (note: there are currently bugs with this) detectAudio: true, // recommend setting this to false to avoid asking for microphone numSources: 4, // number of source buffers to create initially numOutputs: 4, // number of output buffers to use. Note: untested with numbers other than 4. render() method might behave unpredictably extendTransforms: [] // An array of transforms to be added to the synth, or an object representing a single transform precision: null // force precision of shaders, can be \u0026#39;highp\u0026#39;, \u0026#39;mediump\u0026#39;, or \u0026#39;lowp\u0026#39; (recommended for ios). When no precision is specified, will use highp for ios, and mediump for everything else. pb = null, // instance of rtc-patch-bay to use for streaming } Custom render loop # You can use your own render loop for triggering hydra updates, instead of the automatic looping. To use, set autoLoop to false, and call\nhydra.tick(dt) where dt is the time elapsed in milliseconds since the last update\nTo develop: # npm run dev Sets up an example using hydra-synth that is automatically updated when source files are updated. It is possible to write test code by editing /example/index.js or by writing hydra code into the developer console.\nNon-global mode # If makeGlobal is set to false, buffers and functions can be accessed via the synth property of the hydra instance.\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().rotate().out() In non-global mode, it is important to start all hydra functions, buffers, and variables by referencing the instance of hydra synth you are currently using.e.g.\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().diff(h.shape()).out() h.gradient().out(h.o1) h.render() This also makes it possible to use more than one hydra canvas at once:\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().diff(h.shape()).out() h.gradient().out(h.o1) h.render() const h2 = new Hydra({ makeGlobal: false, detectAudio: false }).synth h2.shape(4).diff(h2.osc(2, 0.1, 1.2)).out() See https://glitch.com/edit/#!/multi-hydra for a working example of multiple hydra canvases, created by Naoto Hieda.\nIf you would like to keep the same syntax as hydra in non-global mode, consider destructuring the object further:\nconst { src, osc, gradient, shape, voronoi, noise, s0, s1, s2, s3, o0, o1, o2, o3, render } = hydra shape(4).diff(osc(2, 0.1, 1.2)).out() hydra-ts is a fork of hydra-synth in Typescript maintained by @folz.\nKnown issues / troubleshooting # Vite # When using hydra with Vite, you might see the error\nAutoplay on iOS # from issue https://github.com/hydra-synth/hydra-synth/issues/137\nIt seems on mobile safari, videos won\u0026rsquo;t autoplay because of several reasons:\nyou need playsinline attribute (which can be added programmatically) https://stackoverflow.com/questions/43570460/html5-video-autoplay-on-iphone If the \u0026lt;video\u0026gt; element is not rendered on screen, the video does not update. As a workaround, you can make a small render of the video in a corner and this seems to work \u0026lt;video style=\u0026#34;position:static;top:1px;width:1px;height:1px\u0026#34; id=\u0026#34;vid\u0026#34; autoplay loop muted playsinline crossorigin\u0026gt; \u0026lt;source src=\u0026#34;https://cdn.glitch.global/8df667c3-e544-4cbb-8c16-f604238e8d2e/paper.mov?v=1682418858521\u0026#34;\u0026gt; \u0026lt;/video\u0026gt; let v = document.getElementById(\u0026#34;vid\u0026#34;) v.addEventListener(\u0026#39;loadeddata\u0026#39;, () =\u0026gt; { s0.init({src: v}) }) Here is a live example: https://glitch.com/edit/#!/hydra-video-autoplay-ios\n"},{"id":81,"href":"/docs/docs/learning_old/extending-hydra/","title":"extending hydra","section":"learning","content":" Extending hydra # Hydra is written in javascript, and compatible with many other javascript libraries. The hydra web editor executes javascript directly in the browser, so it is possible to load many other libraries and scripts directly in the browser.\np5.js # p5.js is a JavaScript library for creative coding, with a focus on making coding accessible and inclusive for artists, designers, educators, beginners, and anyone else! p5.js is pre-loaded on the Hydra editor with a wrapper that makes it easier to use inside the website. The wrapper is a class called P5 (notice the upper-case P). A p5.js sketch can be used as a source within a hydra sketch, and vice versa.\np5 + hydra example # // Initialize a new p5 instance It is only necessary to call this once p5 = new P5() // {width: window.innerWidth, height:window.innerHeight, mode: \u0026#39;P2D\u0026#39;} // draw a rectangle at point 300, 100 p5.rect(300, 100, 100, 100) // Note that P5 runs in instance mode, so all functions need to start with the variable where P5 was initialized (in this case p5) // reference for P5: https://P5js.org/reference/ // explanation of instance mode: https://github.com/processing/P5.js/wiki/Global-and-instance-mode // When live coding, the \u0026#34;setup()\u0026#34; function of P5.js has basically no use; anything that you would have called in setup you can just call outside of any function. p5.clear() for(var i = 0; i \u0026lt; 100; i++){ p5.fill(i*10, i%30, 255) p5.rect(i*20, 200, 10,200) } // To live code animations, you can redefine the draw function of P5 as follows: // (a rectangle that follows the mouse) p5.draw = () =\u0026gt; { p5.fill(p5.mouseX/5, p5.mouseY/5, 255, 100) p5.rect(p5.mouseX, p5.mouseY, 30, 150) } // To use P5 as an input to hydra, simply use the canvas as a source: s0.init({src: p5.canvas}) // Then render the canvas src(s0).repeat().out() breakdown of p5.js functions in hydra # p1 = new P5() // first, load p5 in instance mode You can also specify some settings:\np1 = new P5({width: 512, height: 512, mode: \u0026#39;P2D\u0026#39;}) Now the p5 canvas is overlaying the Hydra canvas. You can hide it by running:\np1.hide() // p1.show() to revert And you may load it to a source to use p5\u0026rsquo;s canvas as one:\ns0.init({src: p1.canvas}) p5.setup() # When live coding, the setup() function of p5 has basically no use; anything that you would have called in setup() you can simply call outside of any function. For example:\np1.noStroke() p1.fill(255, 0, 100) p5.draw() # Now, to set a draw loop simply use all the functions and variables you are used to on global p5 from the variable you\u0026rsquo;re using:\np1.draw = () =\u0026gt; { p1.fill(p1.mouseX/5, p1.mouseY/5, 255, 100) p1.rect(p1.mouseX, p1.mouseY, 30, 30) } Livecoding # You can technically call any p5 function while livecoding. So you can draw anything onto screen on evaluation instead of using the draw loop.\np1.clear() for(let i = 0; i \u0026lt; 50; i++) p1.rect(20, 20, p1.width/50*i, p1.height/50*i) Using Hydra\u0026rsquo;s render loop # You can stop p5\u0026rsquo;s own looping and do your p5 actions inside Hydra\u0026rsquo;s render loop via the update function. This will synchronize p5\u0026rsquo;s and Hydra\u0026rsquo;s frame renders.\np1.noLoop(); p1.clear() p1.colorMode(p1.HSB) p1.stroke(0) p1.strokeWeight(1) src(o0) .scale(1.05) .blend(src(o0).brightness(-.02),.4) .modulateHue(o0,100) .layer(s0) .out() p1.draw = () =\u0026gt; { if(p1.random() \u0026lt; 0.01) p1.clear() p1.fill(time*100%200, 70, 100) p1.rect(p1.random()*p1.width, p1.abs(p1.sin(time*2))*p1.height, 50, 50) } update = (dt)=\u0026gt; { p1.redraw(); } You could also use shape drawing functions such as rect directly inside update, but you\u0026rsquo;ll need to take into account the coordinate system won\u0026rsquo;t be reset automatically if modified, like when using draw. So you\u0026rsquo;ll have to reset it manually by putting actions between push() and pop(). This would also stop the frameCount increment.\nNote on using different frame rates # There are many situations where you can save resources by using a very low frame rate on p5 and a high one on Hydra or vice-versa. For example, if you want to place random shapes on the p5 canvas every second, you can set p5\u0026rsquo;s frameRate to 1 and leave Hydra\u0026rsquo;s fps undefined.\nTO DO: add example of using hydra as texture in p5\nLoading external scripts # The await loadScript() function lets you load other packaged javascript libraries within the hydra editor. Any javascript code can run in the hydra editor.\nTHREE.js # Here is an example using Three.js from the web editor:\nawait loadScript(\u0026#34;https://threejs.org/build/three.js\u0026#34;) scene = new THREE.Scene() camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) renderer = new THREE.WebGLRenderer() renderer.setSize(width, height) geometry = new THREE.BoxGeometry() material = new THREE.MeshBasicMaterial({color: 0x00ff00}) cube = new THREE.Mesh(geometry, material); scene.add(cube) camera.position.z = 1.5 // \u0026#39;update\u0026#39; is a reserved function that will be run every time the main hydra rendering context is updated update = () =\u0026gt; { cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render( scene, camera ); } s0.init({ src: renderer.domElement }) src(s0).repeat().out() Tone.js # And here is an example loading the Tone.js library:\nawait loadScript(\u0026#34;https://unpkg.com/tone\u0026#34;) synth = new Tone.Synth().toDestination(); synth.triggerAttackRelease(\u0026#34;C4\u0026#34;, \u0026#34;8n\u0026#34;); Custom libraries # In the Hydra editor, you can load any external scripts, libraries or hydra-synth extensions using the following syntax at the top of your sketch:\nawait loadScript(\u0026#34;https://www.somewebsite.com/url/to/hydra-script.js\u0026#34;) You can also suffer from CORS policy problems if the script/package you\u0026rsquo;re loading doesn\u0026rsquo;t come from a CDN. If you want to load from a GitHub or GitLab repo, you can use special CDNs like statically.io.\ncontributors: geikha, olivia\n"},{"id":82,"href":"/docs/docs/learning_tutorial/guides/guides/automatic-patches/","title":"Iteration: automatically generate patches","section":"Guides","content":" Using iteration and conditionals to create patches # by geikha\nNote # For this tutorial we\u0026rsquo;ll be assuming you\u0026rsquo;ve already learned by your own means what iteration and conditionals are in a programming context.\nIteration : automatically generate patches # As you may know from regular programming, or other creative coding environments such as p5, iteration helps us repeat some operation(s) many times to achieve a specific goal. Maybe you would like to layer many similar objects but with slightly different values, and you want so many of them that writing each one manually isn\u0026rsquo;t desirable. Maybe you want to have some form of very specific feedbacks, etc. Let\u0026rsquo;s jump straight into some examples.\nfor loops # For loops that generate patches can be used inside or outside functions, but we will be sticking with the latter for convenience.\nThe typical structure of a patch-generating for loop is as follows:\nsomeFunction = (iterations) =\u0026gt; { accumulator = osc(); // first part of the patch, a source for(i=1; i\u0026lt;iterations; i++){ // i is also called a \u0026#34;counter` accumulator.someTransform(i); } return accumulator; } someFunction(5).out() Of course this is just a useful example, and your code may end up looking very different depending on what crazy ideas you want to try. But let\u0026rsquo;s use this as a starting point. See how the use of a function allows us to reuse this iterative process with different parameters such as the amount of iterations. Also note how we start the counter variable i on the value 1 instead of the typical 0. Since 0 will usually null an effect, the result will be equal to the first value assigned our accumulator, so we can skip the 0 iteration altogether. For those not familiar with the abbreviation i++, this basically means i+=1, which means i = i+1.\nExample: rotating # Here we want to see how it would look like if we grab an oscillator of a given freq frequency, and calculate the diff between other rotated oscillators of the same frequency. To achieve that, we define our accumulator nest with the initial value of osc(freq,.02). Then, we define a step which will be how many radians the oscillator will rotate. We calculate this as a division of 2pi (a full 360° turn) by some div number. Then we iterate over nest, applying the diff and the effect respectively, and adding a step to our counter r each iteration.\nExample: very specific feedback # Example: layering varying circles # Try adding or changing the transforms that happen to every nextCircle and see how drastically yet easily they can change the visuals. Specially using transforms like repeatX. Still, always keep in mind while using iteration, that the more effects and iterations you add, the heavier the sketch will be to process.\n.forEach, .map and .reduce # Those familiar with more array focused programming languages such as Python or Haskell, or more functional structures even inside JavaScript, may be used to iterating using the forEach, map and/or reduce structures. Where given an Array, we use each value to alter something or to reduce the entire Array into a desired result. Practically anything done with these functions can be done using for loops, so if you are new to these or you just don\u0026rsquo;t like how they look, then there really is no need for you to learn these, even if you\u0026rsquo;re super interested in iteration.\n.forEach # Structures using .forEach are quite useful for those who\u0026rsquo;d like to generate patches from predefined data. Here\u0026rsquo;s an example using the ASCII values of a given string:\nTry changing the text, and remember not to use very long strings given they will be quite heavy to process.\n.reduce # Using .reduce is quite useful when you have an array of textures. Here\u0026rsquo;s a simple example:\n.map # Haters of state (non-political) will prefer .map any day over .forEach. Looking at the example for .forEach, we see were creating a texture and adding it to an accumulator for each element in the Array. We can separate the texture generating part of the code and the blending part using .map to get an array of textures and .reduce to blend them:\nConditionals # Conditionals aren\u0026rsquo;t very useful on their own here, given all code execution on Hydra happens arbitrarily and manually via the interaction of the user. The only case you would want to use an if statement by its own while livecoding Hydra is that where you\u0026rsquo;d like some variable to change given some condition and only at the time of each code evaluation. But even still, you\u0026rsquo;ll see that putting any conditionals inside functions will be the most useful approach because of code reusability and readability. Let\u0026rsquo;s get to it.\nConditionals in functions # We know from previous tutorials we can make our own functions to be used as arguments of Hydra sources and transforms, and how Hydra evaluates these functions each frame. Here\u0026rsquo;s an example where we use conditionals to have a hue change happen only during 3 seconds out of every 10 seconds:\nAnother common use of conditionals in programming is to avoid errors or undesired behaviors. Here\u0026rsquo;s a simple example where we wrap the square root function from the Math API into our own sqrt function which turns any negative input into positive:\nThe ternary operator # Before we go forward and use both iteration and conditionals, we\u0026rsquo;d like to show you the ternary operator. This operator can simplify many conditional operations. The syntax is the following:\nx = condition ? valueIfTrue : valueIfFalse; // which is the same as if(condition) x = valueIfTrue else x = valueIfFalse Now we can simplify the hue change example into:\nosc(20,.1,2.6) .modulate(osc(20).rotate(Math.PI/2),.3) .hue(()=\u0026gt; time%10\u0026lt;3 ? time/2 : 0) .out() Conditionals inside iterations # Let\u0026rsquo;s go back to a previous example, the nest, where we wanted to do many diff using the same oscillator many times with different angles of rotation. Here\u0026rsquo;s a new version where we invert the colors of the first half of oscillators, and we apply colorama to the oscillator in every other iteration.\nThe first change you\u0026rsquo;ll notice is that now we\u0026rsquo;re calculating the angle of rotation r inside the iteration, and for that we now use a regular counter such as i. We can get the exact same angle of rotation as before via multiplying the counter by the step. We do this specifically because if we want to have something happen every other condition, we\u0026rsquo;ll need to know if the number of iteration we\u0026rsquo;re in is even or not. This is what happens at if(i%2==0). However we still make use of r inside of the first conditional, if(r\u0026lt;Math.PI). This will result in about half of the oscillators to be inverted, given Math.PI is half a turn.\n"},{"id":83,"href":"/docs/docs/learning_tutorial/guides/guides/javascript/","title":"javascript for hydra users","section":"Guides","content":" JavaScript Guide # This guide is made for users who are new to JavaScript or coding in general and would like to dive into these topics. You don\u0026rsquo;t need to fully understand what\u0026rsquo;s here to use Hydra. If you\u0026rsquo;re just starting with Hydra and you have no coding experience, we recommend you experiment with Hydra a bit before reading this.\nComments # // This is a one line comment Most programming languages have implemented in them a feature commonly referred as comments. These are ways to write annotations into your code without having the machine interpret them as code. JavaScript, the scripting language that Hydra works on, has implemented comments in the same tradition as many other languages such as Java or C. You use // for single line comments, and you can use /* ... */ for multi-line comments.\n/* An example of a multi line commentary: This sketch shows an oscillator: */ osc().out() You can also write comments at the end of lines of code too, which is very useful while annotating what\u0026rsquo;s going on with your visuals sometimes:\nnoise(2,.5) .diff(src(o0).rotate(Math.PI/4)) // rotating by 45° .thresh(.5) .color(1,.1,.3) // pink color .out() You will surely find useful sometimes to \u0026ldquo;comment in and out\u0026rdquo; some lines of code to see how it affects the visuals, or simply to understand what each line of code does. By adding a // at the start of a line you can comment it out and see how some sketch would look like without a given transform without having to delete the original line.\nnoise(2,.5) .diff(src(o0).rotate(Math.PI/4)) // rotating by 45° //.thresh(.5) .color(1,.1,.3) // pink color .out() Variables # Variables are spaces of memory in your computer that you reserve to store some value. Each variable you use will have a unique symbolic name. This definition may sound complicated, but you\u0026rsquo;ll see it\u0026rsquo;s really as intuitive as it can be. You may remember variables from mathematics being letters that represent some sort of number. This is precisely the same, you just choose some name and assign some number (or other type of information) to it.\nIn the previous example, freq is the name of the variable and 50 is its value.\nVariable names can\u0026rsquo;t start with numbers, they start with letters and it\u0026rsquo;s conventional in JavaScript to start with a lowercase. When the name of your variable is more than one word, it\u0026rsquo;s also conventional to write them as such:\nHowever this is just a convention, you may find other ways of naming your variables more useful. You may even like to use only one letter variables (such as x, y, etc), it\u0026rsquo;s faster to code but harder for others to understand. Find your own balance and style.\nGlobal variables # When you declare a variable in Hydra, it declares it for you on the global scope. You can imagine a scope as a piece of code that works on its own and has its own variables. However, the global scope is basically a bunch of variables and functions that can be accessed from anywhere (functions such as osc() are declared in the global scope so that you can use them by just calling them, no matter where, for example). We can make it explicit that we want something on the global scope. In JavaScript, since it\u0026rsquo;s made to run on a browser, we do this by declaring variables on the window object (what is an object, you can find out below), which represents the browser\u0026rsquo;s window.\nwindow.globalVariable = 21.4 osc(globalVariable).out() However, you can drop the window. part since the default behavior is the same:\nglobalVariable = 21.4 osc(globalVariable).out() If you see JavaScript code elsewhere you\u0026rsquo;ll surely see the keywords let or const. These define variables on their scope. So avoid them if you want to declare variables that can be freely used while livecoding.\nlet scopedVariable = 21.4 // this will only work if evaluated on the same block osc(scopedVariable).out() This knowledge will come in handy if you start coding functions for example, since each function has its own scope, and if you want to declare something on the global scope, you\u0026rsquo;ll have to be explicit about it.\nArrays # Arrays are basically lists of values. Instead of declaring 100 variables to represent different values of the same concept you can just use a list of values. The key thing is these values are related, they will serve the same purpose somewhere in our code. If they are not related, using a list isn\u0026rsquo;t really useful, we\u0026rsquo;ll be just confusing ourselves thinking about where in the list did we put this or that other value. Here\u0026rsquo;s an example of an Array:\nThe example above isn\u0026rsquo;t that useful in a Hydra context, but we hope it illustrates the basics of how an Array is created and used. Arrays in JavaScript (and in most programming languages) start counting their elements from 0 and not from 1. So if you want the first element of the rots Array, you need to call array[0] instead of array[1]! Same goes for every element. If you want the third element call array[2], and so on. Remember that nth element = array[n-1]\nArrays as sequences # Arrays in Hydra can be used as inputs. Hydra takes the list of values and makes a sequence out of them:\nYou can learn more about dynamic inputs here.\nFunctions # A function is similar to a variable in the sense that you\u0026rsquo;re going to give it its own name and call it multiple times later. The difference being that functions do not store values, they store pieces of code that -usually- return some value. You can see them as little boxes where you put something in and they spit something out. Functions will help you not to repeat your code multiple times, sometimes you\u0026rsquo;ll see you can write a function that spits out what you need instead of rewriting it many times.\nDefining functions # There are multiple ways to define functions in JavaScript, here\u0026rsquo;s an example of a function named sum that takes two numbers called a and b and returns (spits out) the sum of both numbers:\nfunction sum(a,b){ return a+b; } sum = function(a,b){ return a+b; } sum = (a,b) =\u0026gt; a+b We\u0026rsquo;ll be sticking with the last form of defining functions, usually called \u0026lsquo;arrow function\u0026rsquo;. It is worth noting the first form it\u0026rsquo;s a bit like using let and const for variables, they work on their own scope.\nLocal variables in functions # Talking about scope, you may want to define variables inside your functions, which are local to the functions and aren\u0026rsquo;t variables that should be used globally. Now the let keyword becomes useful.\nsum = function(a,b){ let result = a+b; return result; } sum = (a,b) =\u0026gt; a+b Functions that return a texture # Now you may be thinking \u0026ldquo;Wait, shouldn\u0026rsquo;t this simply be a variable that stores that texture? If there\u0026rsquo;s no input what\u0026rsquo;s the use of having a function here?\u0026rdquo;. And in a way you would totally be right. Except for the fact that if you use a variable to store that shape, you\u0026rsquo;ll be always referring to the exact same object that represents that shape. If you use a variable circle and apply some transforms to it somewhere in your patch, and try to use circle again later, all the transforms that you applied will be there! Because you applied those to that object precisely. Also, even if you don\u0026rsquo;t apply any transforms, JavaScript can be very messy when referencing the same object multiple times in some situations. So, if you use a function, each time you call it a new object representing that texture will be created. Another reason we would use a function in this example is that if we want to add some input to this function, well, it\u0026rsquo;s already a function so we can do it.\nLet\u0026rsquo;s see how we could make the circle function more useful by adding parameters:\nNow, each time we call the circle function we can specify a size and blur. We can also omit the blur and the function will use the default value specified next to it. We also changed the scaling to an arrow function, which you may find surprising if you haven\u0026rsquo;t seen it before. When you use a function as an argument, Hydra will evaluate that function every time it renders a frame and use the return of that function in the rendering of that frame. In other words, functions can be used as dynamic inputs.\nUsing declared functions as inputs # As we just mentioned, we can use arrow functions inside the arguments of a given source or transform for it to react in real time. If you have many arguments using the same arrow function, you may want to declare it and reuse its name:\nCalling declared functions from other functions # Sometimes you want to reuse a function but have something change about it. For example, maybe we want to make the scaling negative for the feedback in the last example. But calling -scaling doesn\u0026rsquo;t make sense, at least to JavaScript, since the negative of a function doesn\u0026rsquo;t exist. But the negative of its return does:\nNote on functions with parameters # You\u0026rsquo;ll also come across this if your function has parameters. For example:\nscaling = (multiplier)=\u0026gt; (.9+(Math.sin(time*2)/3))*multiplier Doing .scale(scaling) doesn\u0026rsquo;t make sense anymore, since you aren\u0026rsquo;t giving it its necessary input. And if you try to do .scale(scaling(-1)), Hydra will evaluate the function once and use its return as the input to scale, instead of using a function which is what we want for the visual to react to the changes in time. The solution is, again, a function that calls your function, such as .scale(()=\u0026gt;scaling(-1)). If for some reason you hate arrow functions, you could also try binding it doing .scale(scaling.bind(0,1)).\nHigher-order functions # Higher order functions just means functions that take other functions as arguments. These are useful when you want to make u new functions which take behavior from other functions. As an example, let\u0026rsquo;s visualize applying a sine function (with some tweaks) to itself:\nThat new ...args thing simply takes all the arguments sent to a function, we use it so we can call whatever function sent with as many arguments as it needs. Take into account twice(myFunc,time) is the same as myFunc(myFunc(time)), and you may prefer to write the latter in many occasions. But you can also send an arrow function to twice, which could save you declaring a functions you may only want to use once, or writing the same declaration twice.\nObjects # You can imagine an object as a special variable, which instead of containing a value, it contains other variables and functions. The former are usually called properties of an object and the latter are methods of an object. For example, if you ever use Hydra on instance mode, what you\u0026rsquo;ll come across is Hydra as a special object containing all the functions you know and love, instead of having them on the global scope.\nLet\u0026rsquo;s see an example of how to declare and use an object with some properties:\nAnd now let\u0026rsquo;s add a method:\nThere\u0026rsquo;s a new keyword that we hadn\u0026rsquo;t seen before here: this. The this keyword is used in methods (functions of an object) to refer to the object from which the method is called.\nObjects can also be conceptualized as dictionaries, with keys and values. The keys would be the names of the properties (and methods) of the object and the values is what they store:\nnumbers = { pi: 3.14159265359, e: 2.71828182846, golden: 1.61803398875 } numbers[\u0026#39;pi\u0026#39;] // another way we can call keys from an object Useful properties in the window object # The window object has lots of information about the environment that our visuals run on. You\u0026rsquo;ll see lots of Hydra sketches that make use of them, more commonly for example, the innerWidth and innerHeight properties. These properties store the respective width and height that the webpage occupies on your screen.\nFor example, we can calculate the ratio between height and width to have perfect squares on our sketches:\n// this example will only work on the editor or atom-hydra screenRatio = innerHeight/innerWidth shape(4,.4).scale(1,screenRatio) .out() There\u0026rsquo;s also the less used screenX and screenY which will tell you the position of the window relative to the full screen. Try to move your browser\u0026rsquo;s window with the following example:\nThe Math Object # You have surely seen many examples in Hydra and in these tutorials that make use of mathematical functions such as the sine wave. You may have also noticed that each time one of them is used, they\u0026rsquo;re written as Math.somefunction(). The reason for this is that all these very useful functions are taken from a special object called Math that is present in practically every JavaScript implementation. You can see the full list of functions and variables in the Math object clicking here.\nMath.PI # One of the most useful predefined variables that the Math API has is the value of pi (well, an approximation considering that pi has infinite decimals). Many Hydra functions take radians as arguments which you may know are usually represented using multiples of pi. For example, if you want to rotate a texture exactly half a pi (90 degrees), you can do it as such:\nby geikha\n"},{"id":84,"href":"/docs/docs/learning_tutorial/guides/how-to/record-hydra-output/","title":"Record hydra's output","section":"How to","content":" Recording # Saving images from Hydra # You can press Ctrl+Shift+S to save a screenshot of your Hydra\u0026rsquo;s canvas, as well as the code that generates the screenshot. You can also do this programmatically calling the function screencap()\nHydra\u0026rsquo;s built-in recorder # You can very easily record a video evaluating the following commands:\nvidRecorder.start() // run this to start recording vidRecorder.stop() // run this to stop recording and download video Videos recorded with this method are recorded and downloaded with the vp9 codec and webm filetype. However, they can also be quite low quality.\nOBS # OBS is the preferred recording method by most Hydra users. It\u0026rsquo;s a free and open source software for video recording and live streaming available on practically all platforms.\nHow to use OBS # Download and open OBS In the Controls pane on the right side, click on Settings Go to the Output tab, then to the Recording pane and set your preferences. Then click on OK. On the Sources pane, click on the + icon and select Window Capture. If you want to, give the new source a name and click OK Set the Window to the browser your running Hydra on. Most users also prefer to unselect the Capture cursor setting. Click OK. On the preview at the middle of the screen, select your source, right click and then click on Resize output (source size), select Yes. Set your audio input\u0026rsquo;s volume (or mute it) on the Audio Mixer pane. On the Controls pane, click Start Recording. When you want to stop, click Stop Recording. Trim the browser\u0026rsquo;s UI # If you don\u0026rsquo;t want to record your browser\u0026rsquo;s UI, do the following:\nRight click your source and click on Filters. Click on the + icon on the lower left corner and select Crop/Pad. Click OK. Set the values until your UI disappears. Sometimes you only need to set the Top value. Click OK Note on window size # If you want to set your browser\u0026rsquo;s window to a specific size, there are various add-ons on different browsers that allow you to do that. Remember you want to set the size of the view pane and not the whole window.\nby geikha\n"},{"id":85,"href":"/docs/docs/learning/guides/how-to/record-hydra-output/","title":"Record Hydra's output","section":"How to...","content":" Record Hydra\u0026rsquo;s output # by Geikha\nSaving images from Hydra # You can press Ctrl+Shift+S to save a screenshot of your Hydra\u0026rsquo;s canvas, as well as the code that generates the screenshot. You can also do this programmatically calling the function screencap()\nHydra\u0026rsquo;s built-in recorder # You can very easily record a video evaluating the following commands:\nvidRecorder.start() // run this to start recording vidRecorder.stop() // run this to stop recording and download video Videos recorded with this method are recorded and downloaded with the vp9 codec and webm filetype. However, they can also be quite low quality.\nOBS # OBS is the preferred recording method by most Hydra users. It\u0026rsquo;s a free and open source software for video recording and live streaming available on practically all platforms.\nHow to use OBS # Download and open OBS In the Controls pane on the right side, click on Settings Go to the Output tab, then to the Recording pane and set your preferences. Then click on OK. On the Sources pane, click on the + icon and select Window Capture. If you want to, give the new source a name and click OK Set the Window to the browser your running Hydra on. Most users also prefer to unselect the Capture cursor setting. Click OK. On the preview at the middle of the screen, select your source, right click and then click on Resize output (source size), select Yes. Set your audio input\u0026rsquo;s volume (or mute it) on the Audio Mixer pane. On the Controls pane, click Start Recording. When you want to stop, click Stop Recording. Trim the browser\u0026rsquo;s UI # If you don\u0026rsquo;t want to record your browser\u0026rsquo;s UI, do the following:\nRight click your source and click on Filters. Click on the + icon on the lower left corner and select Crop/Pad. Click OK. Set the values until your UI disappears. Sometimes you only need to set the Top value. Click OK Note on window size # If you want to set your browser\u0026rsquo;s window to a specific size, there are various add-ons on different browsers that allow you to do that. Remember you want to set the size of the view pane and not the whole window.\n"},{"id":86,"href":"/docs/docs/learning_tutorial/guides/how-to/use-hydra-without-showing-code/","title":"Use hydra without showing the code","section":"How to","content":" How can I livecode Hydra without showing the code over the visuals? # You can either:\nUse Flok: # Open https://flok.cc/ and create a session with hydra as a target. Now that you have your own Hydra session, with its own URL (it automatically changes on your browser\u0026rsquo;s nav bar), open it in one more tab. Enter the session in both tabs. You can disable Hydra on one of them if you want to (this would also lower resource demand). On one of your tabs, press \u0026ldquo;Ctrl+Shift+H\u0026rdquo; to hide the code. Now you can code on one tab and commands will also run on the other tab!\nUse your browser\u0026rsquo;s dev tools console: # Here\u0026rsquo;s a tutorial by Flor de Fuego about how to do this: [EN] [ES] "},{"id":87,"href":"/docs/docs/learning/guides/how-to/use-hydra-without-showing-code/","title":"Use Hydra without showing the code","section":"How to...","content":" How can I livecode Hydra without showing the code over the visuals? # by Flor de Fuego, Geikha\nUse Flok: # Open https://flok.cc/ and create a session with hydra as a target. Now that you have your own Hydra session, with its own URL (it automatically changes on your browser\u0026rsquo;s nav bar), open it in one more tab. Enter the session in both tabs. You can disable Hydra on one of them if you want to (this would also lower resource demand). On one of your tabs, press \u0026ldquo;Ctrl+Shift+H\u0026rdquo; to hide the code. Now you can code on one tab and commands will also run on the other tab!\nUse your browser\u0026rsquo;s dev tools console: # Here\u0026rsquo;s a tutorial by Flor de Fuego about how to do this:\nEnglish # Spanish # "},{"id":88,"href":"/docs/docs/learning_tutorial/next-steps/extending-hydra/","title":"Using hydra with other javascript libraries","section":"Next Steps","content":" Using hydra with other javascript libraries # Hydra is written in javascript, and compatible with many other javascript libraries. The hydra web editor executes javascript directly in the browser, so it is possible to load many other libraries and scripts directly in the browser.\np5.js # p5.js is a JavaScript library for creative coding, with a focus on making coding accessible and inclusive for artists, designers, educators, beginners, and anyone else! p5.js is pre-loaded on the Hydra editor with a wrapper that makes it easier to use inside the website. The wrapper is a class called P5 (notice the upper-case P). A p5.js sketch can be used as a source within a hydra sketch, and vice versa.\np5 + hydra example # // Initialize a new p5 instance It is only necessary to call this once p5 = new P5() // {width: window.innerWidth, height:window.innerHeight, mode: \u0026#39;P2D\u0026#39;} // draw a rectangle at point 300, 100 p5.rect(300, 100, 100, 100) // Note that P5 runs in instance mode, so all functions need to start with the variable where P5 was initialized (in this case p5) // reference for P5: https://P5js.org/reference/ // explanation of instance mode: https://github.com/processing/P5.js/wiki/Global-and-instance-mode // When live coding, the \u0026#34;setup()\u0026#34; function of P5.js has basically no use; anything that you would have called in setup you can just call outside of any function. p5.clear() for(var i = 0; i \u0026lt; 100; i++){ p5.fill(i*10, i%30, 255) p5.rect(i*20, 200, 10,200) } // To live code animations, you can redefine the draw function of P5 as follows: // (a rectangle that follows the mouse) p5.draw = () =\u0026gt; { p5.fill(p5.mouseX/5, p5.mouseY/5, 255, 100) p5.rect(p5.mouseX, p5.mouseY, 30, 150) } // To use P5 as an input to hydra, simply use the canvas as a source: s0.init({src: p5.canvas}) // Then render the canvas src(s0).repeat().out() breakdown of p5.js functions in hydra # p1 = new P5() // first, load p5 in instance mode You can also specify some settings:\np1 = new P5({width: 512, height: 512, mode: \u0026#39;P2D\u0026#39;}) Now the p5 canvas is overlaying the Hydra canvas. You can hide it by running:\np1.hide() // p1.show() to revert And you may load it to a source to use p5\u0026rsquo;s canvas as one:\ns0.init({src: p1.canvas}) p5.setup() # When live coding, the setup() function of p5 has basically no use; anything that you would have called in setup() you can simply call outside of any function. For example:\np1.noStroke() p1.fill(255, 0, 100) p5.draw() # Now, to set a draw loop simply use all the functions and variables you are used to on global p5 from the variable you\u0026rsquo;re using:\np1.draw = () =\u0026gt; { p1.fill(p1.mouseX/5, p1.mouseY/5, 255, 100) p1.rect(p1.mouseX, p1.mouseY, 30, 30) } Livecoding # You can technically call any p5 function while livecoding. So you can draw anything onto screen on evaluation instead of using the draw loop.\np1.clear() for(let i = 0; i \u0026lt; 50; i++) p1.rect(20, 20, p1.width/50*i, p1.height/50*i) Using Hydra\u0026rsquo;s render loop # You can stop p5\u0026rsquo;s own looping and do your p5 actions inside Hydra\u0026rsquo;s render loop via the update function. This will synchronize p5\u0026rsquo;s and Hydra\u0026rsquo;s frame renders.\np1.noLoop(); p1.clear() p1.colorMode(p1.HSB) p1.stroke(0) p1.strokeWeight(1) src(o0) .scale(1.05) .blend(src(o0).brightness(-.02),.4) .modulateHue(o0,100) .layer(s0) .out() p1.draw = () =\u0026gt; { if(p1.random() \u0026lt; 0.01) p1.clear() p1.fill(time*100%200, 70, 100) p1.rect(p1.random()*p1.width, p1.abs(p1.sin(time*2))*p1.height, 50, 50) } update = (dt)=\u0026gt; { p1.redraw(); } You could also use shape drawing functions such as rect directly inside update, but you\u0026rsquo;ll need to take into account the coordinate system won\u0026rsquo;t be reset automatically if modified, like when using draw. So you\u0026rsquo;ll have to reset it manually by putting actions between push() and pop(). This would also stop the frameCount increment.\nNote on using different frame rates # There are many situations where you can save resources by using a very low frame rate on p5 and a high one on Hydra or vice-versa. For example, if you want to place random shapes on the p5 canvas every second, you can set p5\u0026rsquo;s frameRate to 1 and leave Hydra\u0026rsquo;s fps undefined.\nTO DO: add example of using hydra as texture in p5\nLoading external scripts # The await loadScript() function lets you load other packaged javascript libraries within the hydra editor. Any javascript code can run in the hydra editor.\nTHREE.js # Here is an example using Three.js from the web editor:\nawait loadScript(\u0026#34;https://threejs.org/build/three.js\u0026#34;) scene = new THREE.Scene() camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) renderer = new THREE.WebGLRenderer() renderer.setSize(width, height) geometry = new THREE.BoxGeometry() material = new THREE.MeshBasicMaterial({color: 0x00ff00}) cube = new THREE.Mesh(geometry, material); scene.add(cube) camera.position.z = 1.5 // \u0026#39;update\u0026#39; is a reserved function that will be run every time the main hydra rendering context is updated update = () =\u0026gt; { cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render( scene, camera ); } s0.init({ src: renderer.domElement }) src(s0).repeat().out() Tone.js # And here is an example loading the Tone.js library:\nawait loadScript(\u0026#34;https://unpkg.com/tone\u0026#34;) synth = new Tone.Synth().toDestination(); synth.triggerAttackRelease(\u0026#34;C4\u0026#34;, \u0026#34;8n\u0026#34;); Custom libraries # In the Hydra editor, you can load any external scripts, libraries or hydra-synth extensions using the following syntax at the top of your sketch:\nawait loadScript(\u0026#34;https://www.somewebsite.com/url/to/hydra-script.js\u0026#34;) You can also suffer from CORS policy problems if the script/package you\u0026rsquo;re loading doesn\u0026rsquo;t come from a CDN. If you want to load from a GitHub or GitLab repo, you can use special CDNs like statically.io.\ncontributors: geikha, olivia\n"}]